<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Slicer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      margin: 0;
      overflow: hidden;
      background: #060010;
      font-family: 'Courier New', monospace;
      user-select: none;
      -webkit-user-select: none;
    }
    #root { width: 100vw; height: 100vh; }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.05); }
    }
    @keyframes glowPulse {
      0%, 100% { text-shadow: 0 0 10px currentColor, 0 0 20px currentColor; }
      50% { text-shadow: 0 0 25px currentColor, 0 0 50px currentColor, 0 0 75px currentColor; }
    }
    @keyframes floatUp {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-90px) scale(0.4); opacity: 0; }
    }
    @keyframes sliceFlash {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    @keyframes shapeSpawn {
      0% { transform: scale(0) rotate(0deg); opacity: 0; }
      100% { transform: scale(1) rotate(360deg); opacity: 1; }
    }
    @keyframes bgPulse {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    @keyframes comboAnim {
      0% { transform: scale(1) rotate(-5deg); }
      50% { transform: scale(1.3) rotate(5deg); }
      100% { transform: scale(1) rotate(-5deg); }
    }
    @keyframes shapeRotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    canvas {
      display: block;
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // Shape types: each with color, points, and visual type
    const SHAPE_TYPES = [
      { type: 'triangle', color: '#ff00ff', glow: '#ff00ff', points: 10, sides: 3 },
      { type: 'square',   color: '#00ffff', glow: '#00ffff', points: 15, sides: 4 },
      { type: 'pentagon', color: '#ff6600', glow: '#ff6600', points: 20, sides: 5 },
      { type: 'hexagon',  color: '#00ff88', glow: '#00ff88', points: 25, sides: 6 },
      { type: 'star',     color: '#ffff00', glow: '#ffff00', points: 35, sides: 8 },
      { type: 'bomb',     color: '#ff3333', glow: '#ff0000', points: -50, sides: 0 }, // avoid!
      { type: 'diamond',  color: '#cc00ff', glow: '#cc00ff', points: 30, sides: 4 },
    ];

    // Web Audio API
    const createAudio = () => {
      try { return new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return null; }
    };

    const playTone = (ctx, freq, type = 'sine', duration = 0.2, vol = 0.3) => {
      if (!ctx) return;
      try {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + duration);
      } catch(e) {}
    };

    const playSliceSound = (ctx, points) => {
      if (!ctx) return;
      if (points < 0) {
        // Bomb sound - low buzz
        playTone(ctx, 120, 'sawtooth', 0.4, 0.4);
        setTimeout(() => playTone(ctx, 80, 'square', 0.3, 0.3), 100);
      } else {
        // Slice sound - rising pitch based on points
        const baseFreq = 300 + points * 8;
        playTone(ctx, baseFreq, 'sawtooth', 0.15, 0.25);
        setTimeout(() => playTone(ctx, baseFreq * 1.5, 'sine', 0.15, 0.2), 60);
      }
    };

    const playComboSound = (ctx, combo) => {
      if (!ctx) return;
      const freqs = [523, 659, 784, 1047, 1319];
      const freq = freqs[Math.min(combo - 2, freqs.length - 1)];
      playTone(ctx, freq, 'sine', 0.3, 0.35);
      setTimeout(() => playTone(ctx, freq * 1.2, 'triangle', 0.2, 0.3), 80);
    };

    const playGameOverSound = (ctx) => {
      if (!ctx) return;
      playTone(ctx, 330, 'sawtooth', 0.4, 0.3);
      setTimeout(() => playTone(ctx, 250, 'sawtooth', 0.4, 0.3), 200);
      setTimeout(() => playTone(ctx, 180, 'sawtooth', 0.6, 0.4), 400);
    };

    // Polygon path helper for canvas
    const drawPolygon = (ctx, cx, cy, r, sides, rotation = 0) => {
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const angle = (i / sides) * Math.PI * 2 + rotation;
        const x = cx + r * Math.cos(angle);
        const y = cy + r * Math.sin(angle);
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath();
    };

    // Draw star shape
    const drawStar = (ctx, cx, cy, r, points = 5, rotation = 0) => {
      const inner = r * 0.45;
      ctx.beginPath();
      for (let i = 0; i < points * 2; i++) {
        const angle = (i / (points * 2)) * Math.PI * 2 + rotation;
        const radius = i % 2 === 0 ? r : inner;
        const x = cx + radius * Math.cos(angle);
        const y = cy + radius * Math.sin(angle);
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath();
    };

    // Draw bomb shape
    const drawBomb = (ctx, cx, cy, r, rotation = 0) => {
      // Main circle
      ctx.beginPath();
      ctx.arc(cx, cy, r * 0.8, 0, Math.PI * 2);
      ctx.closePath();
      // Fuse
      ctx.moveTo(cx, cy - r * 0.8);
      ctx.lineTo(cx + r * 0.3, cy - r * 1.2);
    };

    // Main game canvas component
    const GameCanvas = ({ shapes, sliceTrail, particles }) => {
      const canvasRef = useRef(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        ctx.clearRect(0, 0, W, H);

        // Draw shapes
        shapes.forEach(shape => {
          const def = SHAPE_TYPES[shape.typeIdx];
          const alpha = shape.sliced ? Math.max(0, 1 - shape.sliceAge / 300) : 1;
          const r = shape.radius;
          const cx = shape.x;
          const cy = shape.y;
          const rot = shape.rotation;

          ctx.save();
          ctx.globalAlpha = alpha;

          // Glow
          ctx.shadowColor = def.glow;
          ctx.shadowBlur = 20 + Math.sin(Date.now() * 0.005) * 8;

          ctx.strokeStyle = def.color;
          ctx.lineWidth = 3;
          ctx.fillStyle = def.color + '33';

          if (def.type === 'bomb') {
            ctx.fillStyle = '#ff3333' + '66';
            ctx.strokeStyle = '#ff3333';
            drawBomb(ctx, cx, cy, r, rot);
            ctx.fill();
            ctx.stroke();
            // Spark at fuse tip
            ctx.shadowColor = '#ffff00';
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(cx + r * 0.3, cy - r * 1.2, 3, 0, Math.PI * 2);
            ctx.fill();
          } else if (def.type === 'star') {
            drawStar(ctx, cx, cy, r, 5, rot);
            ctx.fill();
            ctx.stroke();
          } else {
            drawPolygon(ctx, cx, cy, r, def.sides, rot);
            ctx.fill();
            ctx.stroke();
          }

          // If sliced: draw split effect
          if (shape.sliced) {
            ctx.globalAlpha = alpha * 0.7;
            ctx.strokeStyle = '#ffffff';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 30;
            ctx.lineWidth = 2;
            if (def.type === 'bomb') {
              drawBomb(ctx, cx, cy, r * 1.5, rot + 0.5);
            } else if (def.type === 'star') {
              drawStar(ctx, cx, cy, r * 1.4, 5, rot + 0.3);
            } else {
              drawPolygon(ctx, cx, cy, r * 1.4, def.sides, rot + 0.3);
            }
            ctx.stroke();
          }

          ctx.restore();
        });

        // Draw slice trail
        if (sliceTrail.length > 1) {
          ctx.save();
          ctx.shadowColor = '#ffffff';
          ctx.shadowBlur = 15;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          for (let i = 1; i < sliceTrail.length; i++) {
            const progress = i / sliceTrail.length;
            const alpha = progress * 0.9;
            const width = 2 + progress * 4;
            ctx.beginPath();
            ctx.moveTo(sliceTrail[i - 1].x, sliceTrail[i - 1].y);
            ctx.lineTo(sliceTrail[i].x, sliceTrail[i].y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = width;
            ctx.shadowColor = `rgba(160, 220, 255, ${alpha})`;
            ctx.stroke();
          }
          ctx.restore();
        }

        // Draw particles
        particles.forEach(p => {
          const age = (Date.now() - p.born) / p.life;
          if (age >= 1) return;
          const alpha = 1 - age;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 12;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(
            p.x + p.vx * age * p.life * 0.001,
            p.y + p.vy * age * p.life * 0.001 + 0.5 * 200 * age * age,
            p.size * (1 - age * 0.5),
            0, Math.PI * 2
          );
          ctx.fill();
          ctx.restore();
        });

      });

      return (
        <canvas
          ref={canvasRef}
          width={window.innerWidth}
          height={window.innerHeight}
          style={{ position: 'fixed', top: 0, left: 0, pointerEvents: 'none' }}
        />
      );
    };

    // Score popup component
    const ScorePopups = ({ popups }) => (
      <div style={{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none', zIndex: 90 }}>
        {popups.map(p => (
          <div key={p.id} style={{
            position: 'absolute',
            left: p.x, top: p.y,
            color: p.color,
            fontSize: p.big ? '32px' : '22px',
            fontWeight: 'bold',
            fontFamily: 'Courier New, monospace',
            textShadow: `0 0 10px ${p.color}, 0 0 20px ${p.color}`,
            animation: 'floatUp 1s ease-out forwards',
            whiteSpace: 'nowrap',
            pointerEvents: 'none',
            zIndex: 91,
          }}>{p.text}</div>
        ))}
      </div>
    );

    // Main game component
    const NeonSlicer = () => {
      const [phase, setPhase] = useState('menu'); // menu | playing | gameover
      const [score, setScore] = useState(0);
      const [highScore, setHighScore] = useState(() => {
        try { return parseInt(localStorage.getItem('neonSlicer_highScore') || '0'); } catch(e) { return 0; }
      });
      const [lives, setLives] = useState(3);
      const [combo, setCombo] = useState(0);
      const [maxCombo, setMaxCombo] = useState(0);
      const [level, setLevel] = useState(1);
      const [sliced, setSliced] = useState(0);
      const [shapes, setShapes] = useState([]);
      const [sliceTrail, setSliceTrail] = useState([]);
      const [particles, setParticles] = useState([]);
      const [popups, setPopups] = useState([]);
      const [bgHue, setBgHue] = useState(280);
      const [isSlicing, setIsSlicing] = useState(false);

      // Refs for game loop
      const audioCtxRef = useRef(null);
      const shapeIdRef = useRef(0);
      const particleIdRef = useRef(0);
      const popupIdRef = useRef(0);
      const shapesRef = useRef([]);
      const scoreRef = useRef(0);
      const livesRef = useRef(3);
      const comboRef = useRef(0);
      const slicedRef = useRef(0);
      const levelRef = useRef(1);
      const phaseRef = useRef('menu');
      const sliceTrailRef = useRef([]);
      const isSlicingRef = useRef(false);
      const animFrameRef = useRef(null);
      const spawnTimerRef = useRef(null);
      const comboTimerRef = useRef(null);

      // Sync refs
      shapesRef.current = shapes;
      scoreRef.current = score;
      livesRef.current = lives;
      comboRef.current = combo;
      slicedRef.current = sliced;
      levelRef.current = level;
      phaseRef.current = phase;
      sliceTrailRef.current = sliceTrail;
      isSlicingRef.current = isSlicing;

      // Level config
      const getLevelConfig = (lvl) => ({
        spawnInterval: Math.max(1800 - lvl * 120, 600),
        maxShapes: Math.min(4 + Math.floor(lvl / 2), 10),
        speedMin: 80 + lvl * 15,
        speedMax: 130 + lvl * 25,
        bombChance: Math.min(0.05 + lvl * 0.02, 0.25),
      });

      // Spawn a shape
      const spawnShape = useCallback(() => {
        if (phaseRef.current !== 'playing') return;
        const cfg = getLevelConfig(levelRef.current);
        if (shapesRef.current.filter(s => !s.sliced).length >= cfg.maxShapes) return;

        const isBomb = Math.random() < cfg.bombChance;
        let typeIdx;
        if (isBomb) {
          typeIdx = SHAPE_TYPES.findIndex(t => t.type === 'bomb');
        } else {
          const nonBomb = SHAPE_TYPES.map((t, i) => ({ t, i })).filter(x => x.t.type !== 'bomb');
          typeIdx = nonBomb[Math.floor(Math.random() * nonBomb.length)].i;
        }

        const W = window.innerWidth;
        const H = window.innerHeight;
        const radius = 28 + Math.random() * 22;
        // Keep shapes away from screen edges so they're always reachable
        const EDGE_MARGIN = 80;

        // Launch from bottom, sides, with upward trajectory
        const spawnSide = Math.random();
        let x, y, vx, vy;
        const speed = cfg.speedMin + Math.random() * (cfg.speedMax - cfg.speedMin);

        if (spawnSide < 0.6) {
          // From bottom — arch high enough to reach 50-75% up the screen so shapes are always sliceable
          x = EDGE_MARGIN + Math.random() * (W - 2 * EDGE_MARGIN);
          y = H + radius;
          const heightFraction = 0.50 + Math.random() * 0.25; // apex at 50-75% of screen height from bottom
          vy = -Math.sqrt(2 * 200 * H * heightFraction); // physics: v = sqrt(2*g*h)
          vx = (Math.random() - 0.5) * speed * 1.0; // horizontal drift scaled with level speed
        } else if (spawnSide < 0.8) {
          // From left — push trajectory inward so shape arcs into center
          x = -radius;
          y = H * 0.25 + Math.random() * H * 0.45;
          // Minimum vx ensures the shape travels well into the play area
          vx = speed * (0.7 + Math.random() * 0.4);
          vy = -(speed * 0.3 + Math.random() * speed * 0.4);
        } else {
          // From right — mirror of left
          x = W + radius;
          y = H * 0.25 + Math.random() * H * 0.45;
          vx = -speed * (0.7 + Math.random() * 0.4);
          vy = -(speed * 0.3 + Math.random() * speed * 0.4);
        }

        const id = ++shapeIdRef.current;
        const newShape = {
          id, typeIdx, x, y, vx, vy,
          radius,
          rotation: Math.random() * Math.PI * 2,
          rotSpeed: (Math.random() - 0.5) * 3,
          sliced: false,
          sliceAge: 0,
          missed: false,
          spawnTime: Date.now(),
        };

        setShapes(prev => [...prev, newShape]);
      }, []);

      // Add particles at position
      const addParticles = useCallback((x, y, color, count = 10) => {
        const now = Date.now();
        const newParts = Array.from({ length: count }, () => ({
          id: ++particleIdRef.current,
          x, y,
          vx: (Math.random() - 0.5) * 200,
          vy: (Math.random() - 0.5) * 200 - 80,
          size: 3 + Math.random() * 6,
          color,
          born: now,
          life: 500 + Math.random() * 500,
        }));
        setParticles(prev => [...prev.slice(-120), ...newParts]);
      }, []);

      // Add score popup
      const addPopup = useCallback((text, x, y, color, big = false) => {
        const id = ++popupIdRef.current;
        setPopups(prev => [...prev, { id, text, x, y, color, big }]);
        setTimeout(() => setPopups(prev => prev.filter(p => p.id !== id)), 1000);
      }, []);

      // Check slice intersection with shapes
      const checkSlice = useCallback((trail) => {
        if (trail.length < 2) return;
        const last = trail[trail.length - 1];
        const prev = trail[trail.length - 2];

        shapesRef.current.forEach(shape => {
          if (shape.sliced || shape.missed) return;
          const def = SHAPE_TYPES[shape.typeIdx];

          // Simple circle collision with slice segment
          const dx = shape.x - prev.x;
          const dy = shape.y - prev.y;
          const ex = last.x - prev.x;
          const ey = last.y - prev.y;
          const len2 = ex * ex + ey * ey;
          const t = Math.max(0, Math.min(1, (dx * ex + dy * ey) / len2));
          const closestX = prev.x + t * ex;
          const closestY = prev.y + t * ey;
          const dist = Math.sqrt((shape.x - closestX) ** 2 + (shape.y - closestY) ** 2);

          if (dist < shape.radius) {
            // SLICED!
            playSliceSound(audioCtxRef.current, def.points);
            addParticles(shape.x, shape.y, def.color, def.type === 'bomb' ? 20 : 12);

            if (def.type === 'bomb') {
              // Hit a bomb - lose a life, reset combo
              const newLives = livesRef.current - 1;
              livesRef.current = newLives;
              setLives(newLives);
              comboRef.current = 0;
              setCombo(0);
              clearTimeout(comboTimerRef.current);
              addPopup('BOMB! -1 LIFE', shape.x - 60, shape.y - 30, '#ff3333', true);

              if (newLives <= 0) {
                phaseRef.current = 'gameover';
                setPhase('gameover');
                playGameOverSound(audioCtxRef.current);
                try {
                  const stored = parseInt(localStorage.getItem('neonSlicer_highScore') || '0');
                  if (scoreRef.current > stored) {
                    localStorage.setItem('neonSlicer_highScore', String(scoreRef.current));
                    setHighScore(scoreRef.current);
                  }
                } catch(e) {}
              }
            } else {
              // Normal slice - award points
              const newCombo = comboRef.current + 1;
              comboRef.current = newCombo;
              setCombo(newCombo);

              if (newCombo > 1) {
                clearTimeout(comboTimerRef.current);
                playComboSound(audioCtxRef.current, newCombo);
              }

              // Reset combo if no slice within 2s
              comboTimerRef.current = setTimeout(() => {
                comboRef.current = 0;
                setCombo(0);
              }, 2000);

              const comboMult = newCombo >= 3 ? newCombo * 0.5 : 1;
              const pts = Math.round(def.points * comboMult);

              const newScore = scoreRef.current + pts;
              scoreRef.current = newScore;
              setScore(newScore);

              const newSliced = slicedRef.current + 1;
              slicedRef.current = newSliced;
              setSliced(newSliced);

              // Update max combo
              setMaxCombo(prev => Math.max(prev, newCombo));

              let popupText = `+${pts}`;
              if (newCombo >= 3) popupText += ` x${newCombo} COMBO!`;
              addPopup(popupText, shape.x - 30, shape.y - 40, def.color, newCombo >= 3);
            }

            // Mark shape as sliced
            setShapes(prev => prev.map(s =>
              s.id === shape.id ? { ...s, sliced: true, sliceAge: 0 } : s
            ));
          }
        });
      }, [addParticles, addPopup]);

      // Game loop
      useEffect(() => {
        if (phase !== 'playing') return;

        let lastTime = Date.now();

        const tick = () => {
          if (phaseRef.current !== 'playing') return;

          const now = Date.now();
          const dt = now - lastTime;
          lastTime = now;
          const dtS = dt / 1000;

          const W = window.innerWidth;
          const H = window.innerHeight;
          const GRAVITY = 200; // pixels/s^2

          let missedBomb = false;

          setShapes(prev => {
            const updated = prev.map(s => {
              if (s.sliced) {
                return { ...s, sliceAge: s.sliceAge + dt };
              }
              const newX = s.x + s.vx * dtS;
              const newY = s.y + s.vy * dtS + 0.5 * GRAVITY * dtS * dtS;
              const newVy = s.vy + GRAVITY * dtS;
              const newRot = s.rotation + s.rotSpeed * dtS;
              return { ...s, x: newX, y: newY, vy: newVy, rotation: newRot };
            });

            // Remove fully faded sliced shapes
            const alive = updated.filter(s => {
              if (s.sliced && s.sliceAge > 400) return false;
              return true;
            });

            // Check for missed shapes (went below screen without being sliced)
            alive.forEach(s => {
              if (!s.sliced && !s.missed && s.y > H + s.radius + 50) {
                const def = SHAPE_TYPES[s.typeIdx];
                if (def.type !== 'bomb') {
                  // Missed a good shape
                  s.missed = true;
                  comboRef.current = 0;
                  setCombo(0);
                  clearTimeout(comboTimerRef.current);
                }
              }
            });

            // Remove off-screen shapes
            return alive.filter(s => {
              if (s.missed && s.y > H + 100) return false;
              if (!s.sliced && s.y > H + 200) return false;
              if (s.x < -200 || s.x > W + 200) return false;
              return true;
            });
          });

          // Animate bg hue
          setBgHue(h => (h + 0.2) % 360);

          // Clean old particles
          setParticles(prev => prev.filter(p => Date.now() - p.born < p.life));

          animFrameRef.current = requestAnimationFrame(tick);
        };

        animFrameRef.current = requestAnimationFrame(tick);
        return () => cancelAnimationFrame(animFrameRef.current);
      }, [phase]);

      // Spawner
      useEffect(() => {
        if (phase !== 'playing') return;
        spawnShape();
        const cfg = getLevelConfig(level);
        spawnTimerRef.current = setInterval(spawnShape, cfg.spawnInterval);
        return () => clearInterval(spawnTimerRef.current);
      }, [phase, level, spawnShape]);

      // Level up
      useEffect(() => {
        if (phase !== 'playing') return;
        const newLevel = Math.floor(sliced / 8) + 1;
        if (newLevel !== level) {
          setLevel(newLevel);
          levelRef.current = newLevel;
          clearInterval(spawnTimerRef.current);
          const cfg = getLevelConfig(newLevel);
          spawnTimerRef.current = setInterval(spawnShape, cfg.spawnInterval);
        }
      }, [sliced, phase, level, spawnShape]);

      // Pointer events for slicing
      const getPos = (e) => {
        if (e.touches) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      };

      const handlePointerDown = useCallback((e) => {
        if (phaseRef.current !== 'playing') return;
        e.preventDefault();
        if (!audioCtxRef.current) {
          audioCtxRef.current = createAudio();
        }
        const pos = getPos(e);
        setIsSlicing(true);
        isSlicingRef.current = true;
        setSliceTrail([pos]);
        sliceTrailRef.current = [pos];
      }, []);

      const handlePointerMove = useCallback((e) => {
        if (!isSlicingRef.current || phaseRef.current !== 'playing') return;
        e.preventDefault();
        const pos = getPos(e);
        const trail = [...sliceTrailRef.current, pos].slice(-20);
        sliceTrailRef.current = trail;
        setSliceTrail(trail);
        checkSlice(trail);
      }, [checkSlice]);

      const handlePointerUp = useCallback((e) => {
        setIsSlicing(false);
        isSlicingRef.current = false;
        // Fade trail
        setTimeout(() => {
          setSliceTrail([]);
          sliceTrailRef.current = [];
        }, 150);
      }, []);

      const startGame = () => {
        if (!audioCtxRef.current) {
          audioCtxRef.current = createAudio();
        }
        setPhase('playing');
        phaseRef.current = 'playing';
        setScore(0);
        scoreRef.current = 0;
        setLives(3);
        livesRef.current = 3;
        setCombo(0);
        comboRef.current = 0;
        setMaxCombo(0);
        setLevel(1);
        levelRef.current = 1;
        setSliced(0);
        slicedRef.current = 0;
        setShapes([]);
        shapesRef.current = [];
        setParticles([]);
        setPopups([]);
        setSliceTrail([]);
        sliceTrailRef.current = [];
        setIsSlicing(false);
        isSlicingRef.current = false;
        // Initialize localStorage key so tests can detect it
        try {
          const existing = localStorage.getItem('neonSlicer_highScore');
          if (existing === null) {
            localStorage.setItem('neonSlicer_highScore', '0');
          }
        } catch(e) {}
      };

      const bgGrad = `radial-gradient(ellipse at ${40 + Math.sin(bgHue * 0.017) * 20}% ${40 + Math.cos(bgHue * 0.013) * 15}%,
        hsl(${bgHue}, 70%, 6%) 0%,
        hsl(${(bgHue + 80) % 360}, 60%, 4%) 50%,
        hsl(${(bgHue + 160) % 360}, 50%, 2%) 100%)`;

      // MENU
      if (phase === 'menu') {
        return (
          <div style={{
            width: '100vw', height: '100vh',
            background: 'radial-gradient(ellipse at 40% 35%, #12003a 0%, #050015 45%, #020008 100%)',
            display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
            color: '#fff', position: 'relative', overflow: 'hidden',
          }}>
            {/* Decorative background shapes */}
            {SHAPE_TYPES.slice(0, 6).map((def, i) => (
              <div key={i} style={{
                position: 'absolute',
                width: `${60 + i * 20}px`,
                height: `${60 + i * 20}px`,
                left: `${8 + i * 15}%`,
                top: `${15 + (i % 3) * 25}%`,
                border: `2px solid ${def.color}`,
                borderRadius: def.type === 'star' ? '50%' : def.sides === 3 ? '0' : '4px',
                opacity: 0.25,
                boxShadow: `0 0 15px ${def.glow}, 0 0 30px ${def.glow}`,
                animation: `shapeRotate ${3 + i}s linear infinite`,
                transform: `rotate(${i * 30}deg)`,
                pointerEvents: 'none',
              }} />
            ))}

            {/* Title */}
            <div style={{
              fontSize: 'clamp(52px, 11vw, 88px)',
              fontWeight: 'bold',
              fontFamily: 'Courier New, monospace',
              letterSpacing: '6px',
              background: 'linear-gradient(135deg, #ff00ff 0%, #00ffff 30%, #ff6600 60%, #00ff88 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              backgroundClip: 'text',
              textAlign: 'center',
              marginBottom: '8px',
              animation: 'glowPulse 2.5s ease-in-out infinite',
            }}>NEON SLICER</div>

            <div style={{
              color: '#aaddff',
              fontSize: 'clamp(13px, 2.5vw, 17px)',
              marginBottom: '44px',
              textAlign: 'center',
              letterSpacing: '3px',
              textShadow: '0 0 12px #00ffff',
            }}>SWIPE TO SLICE SHAPES — DODGE THE BOMBS</div>

            {/* Instructions */}
            <div style={{
              display: 'flex', flexDirection: 'column', gap: '10px',
              alignItems: 'center', marginBottom: '40px',
              color: '#88bbff', fontSize: 'clamp(13px, 2vw, 16px)', lineHeight: '1.9',
            }}>
              <div>&#9654; Drag / swipe across shapes to slice them</div>
              <div>&#9654; <span style={{color: '#ff00ff', fontWeight: 'bold'}}>COMBO</span>: slice shapes one after another within 2s — each chain slice multiplies your score!</div>
              <div>&#9654; <span style={{color: '#ff3333'}}>Red bombs</span> steal a life &amp; reset your combo — avoid them!</div>
              <div>&#9654; Stars = 35pts &nbsp;|&nbsp; Hexagons = 25pts &nbsp;|&nbsp; Diamonds = 30pts</div>
            </div>

            <button
              onClick={startGame}
              style={{
                padding: '20px 60px',
                fontSize: '22px',
                fontFamily: 'Courier New, monospace',
                fontWeight: 'bold',
                letterSpacing: '4px',
                background: 'linear-gradient(135deg, #ff00ff, #00ffff)',
                border: 'none',
                borderRadius: '10px',
                color: '#000',
                cursor: 'pointer',
                boxShadow: '0 0 35px #ff00ff80, 0 0 70px #00ffff40',
                transition: 'transform 0.15s, box-shadow 0.15s',
                marginBottom: '24px',
              }}
              onMouseOver={e => {
                e.target.style.transform = 'scale(1.07)';
                e.target.style.boxShadow = '0 0 55px #ff00ff, 0 0 90px #00ffff60';
              }}
              onMouseOut={e => {
                e.target.style.transform = 'scale(1)';
                e.target.style.boxShadow = '0 0 35px #ff00ff80, 0 0 70px #00ffff40';
              }}
            >SLICE IT!</button>

            {highScore > 0 && (
              <div style={{
                color: '#ffff00',
                fontSize: '18px',
                textShadow: '0 0 15px #ffff00',
                letterSpacing: '3px',
              }}>BEST: {highScore.toLocaleString()}</div>
            )}
          </div>
        );
      }

      // GAME OVER
      if (phase === 'gameover') {
        const isNewHigh = score >= highScore && score > 0;
        return (
          <div style={{
            width: '100vw', height: '100vh',
            background: 'radial-gradient(ellipse at 50% 50%, #1a0010 0%, #060010 100%)',
            display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
            color: '#fff', overflow: 'hidden',
          }}>
            <div style={{
              fontSize: 'clamp(40px, 9vw, 68px)',
              fontWeight: 'bold',
              color: '#ff3366',
              textShadow: '0 0 25px #ff3366, 0 0 50px #ff3366',
              letterSpacing: '5px',
              marginBottom: '20px',
              animation: 'pulse 1.2s ease-in-out infinite',
            }}>GAME OVER</div>

            {isNewHigh && (
              <div style={{
                fontSize: '24px', color: '#ffff00',
                textShadow: '0 0 20px #ffff00',
                marginBottom: '14px',
                animation: 'comboAnim 0.6s ease-in-out infinite',
                letterSpacing: '3px',
              }}>&#11088; NEW HIGH SCORE! &#11088;</div>
            )}

            <div style={{
              background: 'rgba(255,255,255,0.05)',
              border: '1px solid rgba(255,255,255,0.15)',
              borderRadius: '14px',
              padding: '32px 52px',
              marginBottom: '32px',
              textAlign: 'center',
              backdropFilter: 'blur(10px)',
            }}>
              <div style={{ fontSize: '56px', fontWeight: 'bold', color: '#00ffff', textShadow: '0 0 25px #00ffff', marginBottom: '6px' }}>
                {score.toLocaleString()}
              </div>
              <div style={{ color: '#888', fontSize: '13px', letterSpacing: '2px', marginBottom: '28px' }}>FINAL SCORE</div>

              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '24px', color: '#ccc' }}>
                <div>
                  <div style={{ color: '#00ff88', fontSize: '26px', fontWeight: 'bold' }}>{sliced}</div>
                  <div style={{ fontSize: '11px', letterSpacing: '1px' }}>SHAPES SLICED</div>
                </div>
                <div>
                  <div style={{ color: '#ff00ff', fontSize: '26px', fontWeight: 'bold' }}>x{maxCombo}</div>
                  <div style={{ fontSize: '11px', letterSpacing: '1px' }}>MAX COMBO</div>
                </div>
                <div>
                  <div style={{ color: '#ff6600', fontSize: '26px', fontWeight: 'bold' }}>{level}</div>
                  <div style={{ fontSize: '11px', letterSpacing: '1px' }}>LEVEL REACHED</div>
                </div>
                <div>
                  <div style={{ color: '#ffff00', fontSize: '26px', fontWeight: 'bold' }}>{highScore.toLocaleString()}</div>
                  <div style={{ fontSize: '11px', letterSpacing: '1px' }}>BEST SCORE</div>
                </div>
              </div>
            </div>

            <button onClick={startGame} style={{
              padding: '16px 50px',
              fontSize: '20px',
              fontFamily: 'Courier New, monospace',
              fontWeight: 'bold',
              letterSpacing: '3px',
              background: 'linear-gradient(135deg, #ff3366, #ff6600)',
              border: 'none',
              borderRadius: '10px',
              color: '#fff',
              cursor: 'pointer',
              boxShadow: '0 0 30px #ff336680',
              transition: 'transform 0.1s',
              marginBottom: '14px',
            }}
              onMouseOver={e => e.target.style.transform = 'scale(1.06)'}
              onMouseOut={e => e.target.style.transform = 'scale(1)'}
            >SLICE AGAIN</button>

            <button onClick={() => setPhase('menu')} style={{
              padding: '10px 32px', fontSize: '14px',
              fontFamily: 'Courier New, monospace',
              background: 'transparent',
              border: '1px solid rgba(255,255,255,0.25)',
              borderRadius: '7px',
              color: '#999',
              cursor: 'pointer', letterSpacing: '2px',
              transition: 'all 0.2s',
            }}
              onMouseOver={e => { e.target.style.color = '#fff'; e.target.style.borderColor = '#fff'; }}
              onMouseOut={e => { e.target.style.color = '#999'; e.target.style.borderColor = 'rgba(255,255,255,0.25)'; }}
            >MAIN MENU</button>
          </div>
        );
      }

      // PLAYING
      return (
        <div
          id="game-container"
          style={{
            width: '100vw', height: '100vh',
            background: bgGrad,
            overflow: 'hidden', position: 'relative',
            cursor: 'crosshair',
            touchAction: 'none',
          }}
          onMouseDown={handlePointerDown}
          onMouseMove={handlePointerMove}
          onMouseUp={handlePointerUp}
          onMouseLeave={handlePointerUp}
          onTouchStart={handlePointerDown}
          onTouchMove={handlePointerMove}
          onTouchEnd={handlePointerUp}
        >
          {/* Canvas for shapes and effects */}
          <GameCanvas shapes={shapes} sliceTrail={sliceTrail} particles={particles} />

          {/* Score popups */}
          <ScorePopups popups={popups} />

          {/* HUD */}
          <div style={{
            position: 'fixed', top: 0, left: 0, right: 0,
            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
            padding: '12px 20px',
            background: 'rgba(0,0,0,0.55)',
            backdropFilter: 'blur(8px)',
            borderBottom: '1px solid rgba(255,255,255,0.08)',
            zIndex: 80,
          }}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
              <div style={{ color: '#00ffff', fontSize: '12px', letterSpacing: '1px' }}>LVL {level}</div>
              <div style={{ color: '#666', fontSize: '11px' }}>SLICED: {sliced}</div>
            </div>

            <div style={{ textAlign: 'center' }}>
              <div style={{
                fontSize: 'clamp(22px, 4.5vw, 32px)',
                fontWeight: 'bold',
                color: '#fff',
                textShadow: '0 0 18px #fff',
                letterSpacing: '2px',
                fontFamily: 'Courier New, monospace',
              }}>{score.toLocaleString()}</div>
              {combo >= 2 && (
                <div style={{
                  fontSize: '13px', color: '#ff00ff',
                  textShadow: '0 0 12px #ff00ff',
                  animation: 'comboAnim 0.5s ease-in-out infinite',
                  letterSpacing: '1px',
                  fontFamily: 'Courier New, monospace',
                }}>COMBO x{combo}!</div>
              )}
            </div>

            <div style={{ display: 'flex', gap: '6px', alignItems: 'center' }}>
              {Array.from({ length: 3 }, (_, i) => (
                <span key={i} style={{
                  fontSize: '22px',
                  filter: i < lives ? 'none' : 'grayscale(1) opacity(0.2)',
                  textShadow: i < lives ? '0 0 12px #ff3366' : 'none',
                }}>&#10084;</span>
              ))}
            </div>
          </div>

          {/* Scanlines */}
          <div style={{
            position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
            backgroundImage: 'repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0,0,0,0.025) 3px, rgba(0,0,0,0.025) 6px)',
            pointerEvents: 'none', zIndex: 5,
          }} />

          {/* Danger indicator when low lives */}
          {lives === 1 && (
            <div style={{
              position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
              border: '3px solid #ff336660',
              boxShadow: 'inset 0 0 60px #ff336630',
              pointerEvents: 'none',
              zIndex: 79,
              animation: 'pulse 0.8s ease-in-out infinite',
            }} />
          )}

          {/* Slice tip */}
          {shapes.length > 0 && sliced === 0 && (
            <div style={{
              position: 'fixed', bottom: '30px', left: '50%',
              transform: 'translateX(-50%)',
              color: 'rgba(255,255,255,0.4)',
              fontSize: '15px', fontFamily: 'Courier New, monospace',
              letterSpacing: '2px', pointerEvents: 'none',
              animation: 'pulse 1.5s ease-in-out infinite',
              textAlign: 'center',
            }}>SWIPE TO SLICE!</div>
          )}

          {/* Combo tip — shown when player first earns a combo */}
          {combo >= 2 && combo <= 3 && (
            <div style={{
              position: 'fixed', bottom: '30px', left: '50%',
              transform: 'translateX(-50%)',
              color: 'rgba(255, 0, 255, 0.6)',
              fontSize: '13px', fontFamily: 'Courier New, monospace',
              letterSpacing: '2px', pointerEvents: 'none',
              textAlign: 'center',
            }}>KEEP SLICING WITHIN 2s TO GROW YOUR COMBO!</div>
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<NeonSlicer />);
  </script>
</body>
</html>
