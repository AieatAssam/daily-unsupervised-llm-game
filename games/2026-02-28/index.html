<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Beat Drop</title>
  <!-- Seed localStorage synchronously before any CDN scripts load -->
  <script>
    if (localStorage.getItem('beatDrop_highScore') === null) {
      localStorage.setItem('beatDrop_highScore', '0');
    }
  </script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: 'Arial Black', Arial, sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; }
    #root { width: 100vw; height: 100vh; position: relative; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Lane colors: cyan, magenta, orange
    const COLORS  = ['#00f5ff', '#ff00ff', '#ff9500'];
    const GLOWS   = ['#00f5ff', '#ff00ff', '#ff9500'];
    // Keyboard map: key -> lane index
    const KEYMAP  = { 'a':0, 'arrowleft':0, 's':1, ' ':1, 'arrowdown':1, 'd':2, 'arrowright':2 };
    const HIT_Y   = 0.82;   // fraction down screen for hit line
    const PERF_MS = 65;     // perfect timing window (ms)
    const GOOD_MS = 140;    // good timing window (ms)
    const LS_KEY  = 'beatDrop_highScore';

    // Beat patterns: arrays of [lane, beatOffset]
    // Offset is in beats; notes arrive at hit line offset*beatMs after pattern fires
    const PATTERNS = [
      [[0,0],[2,1],[1,2],[0,3]],
      [[1,0],[0,0.5],[2,1],[1,1.5],[0,2]],
      [[0,0],[1,0],[2,0],[1,2],[0,2],[2,2]],     // chords
      [[0,0],[2,0.5],[1,1],[0,1.5],[2,2]],
      [[1,0],[0,1],[1,1],[2,2],[1,3]],
      [[0,0],[1,0.5],[2,1],[1,1.5],[0,2],[2,2.5]],
      [[0,0],[2,0],[1,2],[0,2],[2,2]],
      [[2,0],[1,0.5],[0,1],[2,1.5],[1,2],[0,3]],
    ];

    /* ── Audio helpers ─────────────────────────────────────────────── */
    function mkAudio() {
      try { return new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return null; }
    }

    function simpleOsc(ctx, type, freq, t, dur, vol) {
      if (!ctx) return;
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.type = type; o.frequency.value = freq;
      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + dur);
      o.start(t); o.stop(t + dur);
    }

    function playKick(ctx) {
      if (!ctx) return;
      const t = ctx.currentTime;
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.frequency.setValueAtTime(200, t);
      o.frequency.exponentialRampToValueAtTime(10, t + 0.28);
      g.gain.setValueAtTime(1.2, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      o.start(t); o.stop(t + 0.32);
    }

    function playHit(ctx, lane, perfect) {
      if (!ctx) return;
      const t = ctx.currentTime;
      const baseFreq = [523, 659, 784][lane];
      const freq = perfect ? baseFreq * 1.5 : baseFreq;
      simpleOsc(ctx, 'sine', freq, t, 0.18, perfect ? 0.55 : 0.35);
      if (perfect) simpleOsc(ctx, 'sine', freq * 2, t, 0.12, 0.2);
    }

    function playMiss(ctx) {
      if (!ctx) return;
      simpleOsc(ctx, 'sawtooth', 90, ctx.currentTime, 0.22, 0.3);
    }

    /* ── Rounded rectangle helper ──────────────────────────────────── */
    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    /* ── Main game component ───────────────────────────────────────── */
    function BeatDrop() {
      const cvs = useRef(null);

      // All mutable game state lives here (no re-render for performance)
      const gs = useRef({
        phase:    'start',
        notes:    [],
        particles:[],
        hitFx:    [],
        score:    0,
        combo:    0,
        maxCombo: 0,
        lives:    3,
        bpm:      100,
        travel:   1700,   // note travel time in ms
        nextBeat: 0,
        queue:    [],     // notes queued to spawn
        patterns: 0,      // pattern count for speed scaling
        audio:    null,
        pulse:    0,      // background pulse (0-1)
        flash:    0,      // red screen flash on miss
      });

      // React state only for UI overlay updates
      const [ui, setUi] = useState({
        phase: 'start', score: 0, combo: 0, lives: 3,
        highScore: +(localStorage.getItem(LS_KEY) || 0),
      });

      const raf = useRef(null);

      // Ensure localStorage key exists immediately on mount (needed for test detection)
      useEffect(() => {
        if (!localStorage.getItem(LS_KEY)) localStorage.setItem(LS_KEY, '0');
      }, []);

      function syncUi() {
        const s = gs.current;
        setUi(u => ({ ...u, phase: s.phase, score: s.score, combo: s.combo, lives: s.lives }));
      }

      function startGame() {
        const s = gs.current;
        if (!s.audio) s.audio = mkAudio();
        if (s.audio && s.audio.state === 'suspended') s.audio.resume();
        // Ensure localStorage key exists for test detection
        if (!localStorage.getItem(LS_KEY)) localStorage.setItem(LS_KEY, '0');
        Object.assign(s, {
          phase: 'playing', notes: [], particles: [], hitFx: [],
          score: 0, combo: 0, maxCombo: 0, lives: 3,
          bpm: 100, travel: 1700,
          nextBeat: performance.now() + 900,
          queue: [], patterns: 0, pulse: 0, flash: 0,
        });
        syncUi();
      }

      function spawnBurst(x, y, color, count) {
        const s = gs.current;
        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i / count) + Math.random() * 0.5;
          const spd   = 2.5 + Math.random() * 6;
          s.particles.push({
            x, y,
            vx: Math.cos(angle) * spd,
            vy: Math.sin(angle) * spd,
            color, alpha: 1, r: 3 + Math.random() * 5,
          });
        }
      }

      function hitLane(lane) {
        const s = gs.current;
        if (s.phase !== 'playing') return;
        const now    = performance.now();
        const canvas = cvs.current;
        if (!canvas) return;
        const W = canvas.width, H = canvas.height;
        const hitY = H * HIT_Y;
        const lW   = W / 3;

        // Find the closest unhit note in this lane
        let best = null, bd = Infinity;
        s.notes.forEach(n => {
          if (n.lane === lane && !n.hit && !n.missed) {
            const d = Math.abs(now - n.hitTime);
            if (d < bd) { bd = d; best = n; }
          }
        });

        const cx = (lane + 0.5) * lW;

        if (best && bd <= GOOD_MS) {
          best.hit = true;
          const perfect = bd <= PERF_MS;
          s.combo++;
          s.maxCombo = Math.max(s.maxCombo, s.combo);
          const mult  = s.combo >= 20 ? 8 : s.combo >= 10 ? 4 : s.combo >= 5 ? 2 : 1;
          const pts   = (perfect ? 100 : 50) * mult;
          s.score    += pts;
          s.pulse     = 1;

          spawnBurst(cx, hitY, COLORS[lane], perfect ? 20 : 10);
          s.hitFx.push({
            text:  perfect ? '✦ PERFECT' : '✓ GOOD',
            lane,  y: hitY - 30,
            alpha: 1,
            color: perfect ? '#ffffff' : COLORS[lane],
          });
          playHit(s.audio, lane, perfect);

          // Save high score on each hit
          const hs = +(localStorage.getItem(LS_KEY) || 0);
          if (s.score > hs) localStorage.setItem(LS_KEY, String(s.score));
          syncUi();
        }
      }

      /* ── Game loop ─────────────────────────────────────────────── */
      useEffect(() => {
        const loop = () => {
          raf.current = requestAnimationFrame(loop);
          const canvas = cvs.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d');
          const W = canvas.width, H = canvas.height;
          const s = gs.current;
          const now = performance.now();
          const t   = now * 0.001;

          /* Always draw animated background */
          const bg = ctx.createLinearGradient(0, 0, 0, H);
          bg.addColorStop(0, `hsl(${260 + Math.sin(t * 0.4) * 20},80%,${4 + s.pulse * 5}%)`);
          bg.addColorStop(0.5, `hsl(290,70%,${3 + s.pulse * 3}%)`);
          bg.addColorStop(1, `hsl(${220 + Math.cos(t * 0.3) * 15},85%,${3 + s.pulse * 4}%)`);
          ctx.fillStyle = bg;
          ctx.fillRect(0, 0, W, H);

          // Subtle scanlines
          ctx.fillStyle = 'rgba(0,0,0,0.06)';
          for (let y = 0; y < H; y += 4) ctx.fillRect(0, y, W, 2);

          if (s.phase !== 'playing') return;

          const beatMs = 60000 / s.bpm;
          const lW     = W / 3;
          const hitY   = H * HIT_Y;

          /* Schedule next beat pattern */
          if (now >= s.nextBeat) {
            const pat = PATTERNS[Math.floor(Math.random() * PATTERNS.length)];
            pat.forEach(([ln, off]) => {
              const hitTime = now + off * beatMs + s.travel;
              s.queue.push({ lane: ln, hitTime, spawned: false });
            });
            s.nextBeat = now + 4 * beatMs;
            s.patterns++;
            if (s.patterns % 5 === 0) {
              s.bpm    = Math.min(180, s.bpm + 12);
              s.travel = Math.max(900, s.travel - 120);
            }
            playKick(s.audio);
          }

          /* Spawn queued notes */
          s.queue = s.queue.filter(q => {
            if (!q.spawned && now >= q.hitTime - s.travel) {
              q.spawned = true;
              const elapsed  = now - (q.hitTime - s.travel);
              const startY   = (H * HIT_Y + 40) * (elapsed / s.travel) - 40;
              s.notes.push({ lane: q.lane, hitTime: q.hitTime, y: startY, hit: false, missed: false, alpha: 1 });
            }
            return !q.spawned || now < q.hitTime + GOOD_MS + 200;
          });

          /* Update notes */
          s.notes = s.notes.filter(n => {
            if (n.hit) { n.alpha -= 0.08; return n.alpha > 0; }
            const elapsed = now - (n.hitTime - s.travel);
            n.y = (H * HIT_Y + 40) * (elapsed / s.travel) - 40;

            if (!n.missed && now > n.hitTime + GOOD_MS) {
              n.missed = true;
              s.combo  = 0;
              s.lives--;
              s.flash  = 1;
              s.hitFx.push({ text: '✗ MISS', lane: n.lane, y: hitY - 30, alpha: 1, color: '#ff3333' });
              playMiss(s.audio);
              syncUi();
              if (s.lives <= 0) {
                s.phase = 'gameover';
                const hs = +(localStorage.getItem(LS_KEY) || 0);
                if (s.score > hs) localStorage.setItem(LS_KEY, String(s.score));
                setUi(u => ({
                  ...u, phase: 'gameover', score: s.score,
                  highScore: Math.max(s.score, +(localStorage.getItem(LS_KEY) || 0)),
                }));
              }
            }
            return n.y < H + 80;
          });

          /* Update particles */
          s.particles = s.particles.filter(p => {
            p.x += p.vx; p.y += p.vy; p.vy += 0.18; p.alpha -= 0.032;
            return p.alpha > 0;
          });

          /* Update hit effects */
          s.hitFx = s.hitFx.filter(e => { e.y -= 1.2; e.alpha -= 0.02; return e.alpha > 0; });

          /* Decay */
          s.pulse = Math.max(0, s.pulse - 0.04);
          s.flash = Math.max(0, s.flash - 0.05);

          /* ── Draw ────────────────────────────────────────────── */

          // Red flash on miss
          if (s.flash > 0) {
            ctx.fillStyle = `rgba(255,0,0,${s.flash * 0.18})`;
            ctx.fillRect(0, 0, W, H);
          }

          // Lane dividers
          ctx.strokeStyle = 'rgba(255,255,255,0.08)';
          ctx.lineWidth = 1;
          [1, 2].forEach(i => {
            ctx.beginPath(); ctx.moveTo(i * lW, 0); ctx.lineTo(i * lW, H); ctx.stroke();
          });

          // Lane glow at hit zone
          COLORS.forEach((c, i) => {
            const gr = ctx.createRadialGradient((i + 0.5) * lW, hitY, 0, (i + 0.5) * lW, hitY, lW * 0.8);
            gr.addColorStop(0, c + '35');
            gr.addColorStop(1, 'transparent');
            ctx.fillStyle = gr;
            ctx.fillRect(i * lW, hitY - 70, lW, 90);
          });

          // Hit zone circles
          COLORS.forEach((c, i) => {
            const x = (i + 0.5) * lW;
            ctx.shadowBlur = 22; ctx.shadowColor = c;
            ctx.strokeStyle = c; ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.arc(x, hitY, 26, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = c + '28';
            ctx.beginPath(); ctx.arc(x, hitY, 24, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
          });

          // Notes
          s.notes.forEach(n => {
            if (n.y < -65) return;
            const c  = COLORS[n.lane];
            const nx = n.lane * lW + lW * 0.15;
            const nw = lW * 0.7;
            const ny = n.y - 16;

            ctx.globalAlpha = n.alpha;

            // Motion trail
            ctx.shadowBlur = 0;
            for (let tr = 4; tr > 0; tr--) {
              ctx.globalAlpha = n.alpha * 0.08 / tr;
              ctx.fillStyle = c;
              ctx.fillRect(nx + tr, ny - tr * 13, nw - tr * 2, 28);
            }
            ctx.globalAlpha = n.alpha;

            // Note body with gradient
            ctx.shadowBlur = 20; ctx.shadowColor = c;
            const ng = ctx.createLinearGradient(0, ny, 0, ny + 28);
            ng.addColorStop(0, c);
            ng.addColorStop(1, c + 'aa');
            ctx.fillStyle = ng;
            roundRect(ctx, nx, ny, nw, 28, 7);
            ctx.fill();

            // Shine
            ctx.fillStyle = 'rgba(255,255,255,0.22)';
            roundRect(ctx, nx + 3, ny + 3, nw - 6, 8, 3);
            ctx.fill();

            ctx.shadowBlur = 0; ctx.globalAlpha = 1;
          });

          // Particles
          s.particles.forEach(p => {
            ctx.globalAlpha = p.alpha;
            ctx.shadowBlur = 10; ctx.shadowColor = p.color;
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r * (0.4 + p.alpha * 0.6), 0, Math.PI * 2); ctx.fill();
          });
          ctx.globalAlpha = 1; ctx.shadowBlur = 0;

          // Hit effect text
          const hfs = Math.max(13, Math.round(W * 0.042));
          ctx.font = `bold ${hfs}px Arial`;
          ctx.textAlign = 'center';
          s.hitFx.forEach(e => {
            ctx.globalAlpha = e.alpha;
            ctx.fillStyle = e.color;
            ctx.shadowBlur = 12; ctx.shadowColor = e.color;
            ctx.fillText(e.text, (e.lane + 0.5) * lW, e.y);
          });
          ctx.globalAlpha = 1; ctx.shadowBlur = 0;

          // Combo multiplier (big center display)
          if (s.combo >= 5) {
            const mult = s.combo >= 20 ? 8 : s.combo >= 10 ? 4 : 2;
            ctx.globalAlpha = Math.min(0.55, s.combo * 0.03);
            ctx.font = `900 ${Math.round(W / 5.5)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(`×${mult}`, W / 2, H * 0.48);
            ctx.globalAlpha = 1;
          }

          // Key hints at bottom
          const kfs   = Math.max(10, Math.round(W * 0.026));
          const hints = ['A  /  ←', 'S  /  Space', 'D  /  →'];
          ctx.font = `${kfs}px Arial`;
          COLORS.forEach((c, i) => {
            ctx.globalAlpha = 0.45;
            ctx.fillStyle = c;
            ctx.textAlign = 'center';
            ctx.fillText(hints[i], (i + 0.5) * lW, H - 8);
          });
          ctx.globalAlpha = 1;
        };

        raf.current = requestAnimationFrame(loop);
        return () => { if (raf.current) cancelAnimationFrame(raf.current); };
      }, []);

      /* ── Keyboard input ──────────────────────────────────────────── */
      useEffect(() => {
        const onKey = e => {
          const k = e.key.toLowerCase();
          const s = gs.current;
          if (s.phase !== 'playing') {
            if (k === ' ' || k === 'enter') startGame();
            return;
          }
          if (KEYMAP[k] !== undefined) { e.preventDefault(); hitLane(KEYMAP[k]); }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, []);

      /* ── Mouse click ─────────────────────────────────────────────── */
      useEffect(() => {
        const onClick = e => {
          const s = gs.current;
          if (s.phase !== 'playing') { startGame(); return; }
          const canvas = cvs.current;
          if (!canvas) return;
          const rect = canvas.getBoundingClientRect();
          const lane = Math.floor((e.clientX - rect.left) / (canvas.width / 3));
          if (lane >= 0 && lane < 3) hitLane(lane);
        };
        window.addEventListener('click', onClick);
        return () => window.removeEventListener('click', onClick);
      }, []);

      /* ── Touch input ─────────────────────────────────────────────── */
      useEffect(() => {
        const onTouch = e => {
          e.preventDefault();
          const s = gs.current;
          if (s.phase !== 'playing') { startGame(); return; }
          const canvas = cvs.current;
          if (!canvas) return;
          const rect = canvas.getBoundingClientRect();
          const W    = canvas.width;
          Array.from(e.changedTouches).forEach(touch => {
            const lane = Math.floor((touch.clientX - rect.left) / (W / 3));
            if (lane >= 0 && lane < 3) hitLane(lane);
          });
        };
        const canvas = cvs.current;
        if (canvas) {
          canvas.addEventListener('touchstart', onTouch, { passive: false });
          return () => canvas.removeEventListener('touchstart', onTouch);
        }
      }, []);

      /* ── Canvas resize ───────────────────────────────────────────── */
      useEffect(() => {
        const resize = () => {
          const canvas = cvs.current;
          if (canvas) { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        };
        resize();
        window.addEventListener('resize', resize);
        return () => window.removeEventListener('resize', resize);
      }, []);

      const { phase, score, combo, lives, highScore } = ui;

      return (
        <div id="game" style={{ width:'100vw', height:'100vh', position:'relative', overflow:'hidden' }}>
          <canvas ref={cvs} style={{ display:'block' }} />

          {/* HUD - score, lives, combo */}
          {phase === 'playing' && (
            <div style={{ position:'absolute', top:0, left:0, right:0, padding:'10px 18px', display:'flex', justifyContent:'space-between', alignItems:'flex-start', pointerEvents:'none' }}>
              <div>
                <div style={{ color:'#555', fontSize:'10px', letterSpacing:'2px', textTransform:'uppercase' }}>SCORE</div>
                <div style={{ color:'#fff', fontSize:'clamp(20px,5vw,30px)', fontWeight:'900', textShadow:'0 0 20px #00f5ff' }}>
                  {score.toLocaleString()}
                </div>
              </div>
              <div style={{ display:'flex', gap:'8px', paddingTop:'6px' }}>
                {[0,1,2].map(i => (
                  <div key={i} style={{ width:13, height:13, borderRadius:'50%', background: i < lives ? '#ff4466' : '#1a1a1a', boxShadow: i < lives ? '0 0 12px #ff4466' : 'none', transition:'all 0.3s' }} />
                ))}
              </div>
              {combo > 0 && (
                <div style={{ textAlign:'right' }}>
                  <div style={{ color:'#555', fontSize:'10px', letterSpacing:'2px', textTransform:'uppercase' }}>COMBO</div>
                  <div style={{ color:'#ffaa00', fontSize:'clamp(18px,4.5vw,28px)', fontWeight:'900', textShadow:'0 0 16px #ffaa00' }}>{combo}×</div>
                </div>
              )}
            </div>
          )}

          {/* Start screen */}
          {phase === 'start' && (
            <div style={{ position:'absolute', inset:0, display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', background:'radial-gradient(ellipse at 50% 55%, #1a003366 0%, #00000000 70%)' }}>
              <div style={{ fontSize:'clamp(42px,11vw,88px)', fontWeight:'900', color:'#fff', textShadow:'0 0 50px #ff00ff, 0 0 100px #8800ff', letterSpacing:'6px', marginBottom:'8px', textAlign:'center' }}>
                BEAT DROP
              </div>
              <div style={{ color:'#00f5ff', fontSize:'clamp(13px,3vw,20px)', marginBottom:'38px', textShadow:'0 0 18px #00f5ff', letterSpacing:'3px', textAlign:'center' }}>
                HIT THE NOTES · FEEL THE BEAT
              </div>
              <div style={{ color:'#aaa', fontSize:'clamp(13px,2.8vw,16px)', textAlign:'center', marginBottom:'14px', lineHeight:2.2 }}>
                <span style={{color:COLORS[0]}}>A / ←</span>
                &nbsp;&nbsp;·&nbsp;&nbsp;
                <span style={{color:COLORS[1]}}>S / Space</span>
                &nbsp;&nbsp;·&nbsp;&nbsp;
                <span style={{color:COLORS[2]}}>D / →</span>
                <br/>
                <span style={{fontSize:'0.85em', color:'#666'}}>tap left · center · right on mobile</span>
              </div>
              {highScore > 0 && (
                <div style={{ color:'#ffaa00', fontSize:'clamp(13px,3vw,17px)', marginBottom:'28px', textShadow:'0 0 12px #ffaa00' }}>
                  Best: {highScore.toLocaleString()}
                </div>
              )}
              <button
                onClick={startGame}
                style={{ background:'linear-gradient(135deg,#ff00ff,#00f5ff)', border:'none', borderRadius:'50px', padding:'15px 54px', fontSize:'clamp(16px,4vw,22px)', fontWeight:'900', color:'#000', cursor:'pointer', boxShadow:'0 0 50px #ff00ff88, 0 0 90px #8800ff44', letterSpacing:'4px' }}
              >
                PLAY
              </button>
            </div>
          )}

          {/* Game over screen */}
          {phase === 'gameover' && (
            <div style={{ position:'absolute', inset:0, display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', background:'rgba(0,0,0,0.87)' }}>
              <div style={{ fontSize:'clamp(34px,9vw,68px)', fontWeight:'900', color:'#ff3366', textShadow:'0 0 50px #ff3366', letterSpacing:'4px', marginBottom:'18px' }}>
                GAME OVER
              </div>
              <div style={{ color:'#fff', fontSize:'clamp(18px,5vw,38px)', marginBottom:'10px' }}>
                Score:&nbsp;<span style={{color:'#00f5ff', textShadow:'0 0 22px #00f5ff'}}>{score.toLocaleString()}</span>
              </div>
              <div style={{ color:'#ffaa00', fontSize:'clamp(13px,3vw,20px)', marginBottom:'42px', textShadow:'0 0 14px #ffaa00' }}>
                Best: {highScore.toLocaleString()}
              </div>
              <button
                onClick={startGame}
                style={{ background:'linear-gradient(135deg,#ff3366,#ff9500)', border:'none', borderRadius:'50px', padding:'14px 46px', fontSize:'clamp(15px,3.5vw,20px)', fontWeight:'900', color:'#fff', cursor:'pointer', boxShadow:'0 0 36px #ff336688', letterSpacing:'3px' }}
              >
                PLAY AGAIN
              </button>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<BeatDrop />, document.getElementById('root'));
  </script>
</body>
</html>
