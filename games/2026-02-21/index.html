<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Circuit Blaze</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #050010;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    #root { width: 100vw; height: 100vh; position: relative; }
    canvas { display: block; }
    .hud {
      position: absolute;
      top: 0; left: 0; right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%);
      pointer-events: none;
    }
    .hud-block { text-align: center; }
    .hud-label {
      font-size: 10px;
      color: rgba(255,255,255,0.5);
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    .hud-value {
      font-size: 22px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 10px currentColor;
    }
    .hud-score { color: #00ffff; text-shadow: 0 0 12px #00ffff; }
    .hud-combo { color: #ff00ff; text-shadow: 0 0 12px #ff00ff; }
    .hud-best  { color: #ffff00; text-shadow: 0 0 12px #ffff00; }
    .lives { display: flex; gap: 6px; align-items: center; }
    .heart {
      width: 18px; height: 18px;
      filter: drop-shadow(0 0 6px #ff4488);
      transition: transform 0.2s;
    }
    .heart.lost { opacity: 0.2; filter: none; }
    .screen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: all;
      cursor: pointer;
    }
    .title {
      font-size: clamp(36px, 8vw, 72px);
      font-weight: 900;
      letter-spacing: 4px;
      background: linear-gradient(135deg, #00ffff, #ff00ff, #ffff00);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 20px rgba(0,255,255,0.5));
      text-align: center;
    }
    .subtitle {
      font-size: clamp(12px, 2.5vw, 18px);
      color: rgba(255,255,255,0.7);
      margin-top: 12px;
      letter-spacing: 2px;
      text-align: center;
      padding: 0 20px;
    }
    .instructions {
      margin-top: 30px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      text-align: center;
    }
    .inst-row {
      font-size: clamp(11px, 2vw, 14px);
      color: rgba(255,255,255,0.6);
      letter-spacing: 1px;
    }
    .inst-row span { color: #00ffff; }
    .start-btn {
      margin-top: 40px;
      padding: 14px 48px;
      border: 2px solid #00ffff;
      background: rgba(0,255,255,0.1);
      color: #00ffff;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      font-weight: bold;
      letter-spacing: 4px;
      cursor: pointer;
      pointer-events: all;
      transition: all 0.2s;
      box-shadow: 0 0 20px rgba(0,255,255,0.3), inset 0 0 20px rgba(0,255,255,0.05);
      text-transform: uppercase;
    }
    .start-btn:hover {
      background: rgba(0,255,255,0.2);
      box-shadow: 0 0 40px rgba(0,255,255,0.6), inset 0 0 20px rgba(0,255,255,0.1);
      transform: scale(1.05);
    }
    .final-score {
      font-size: clamp(48px, 10vw, 80px);
      font-weight: 900;
      color: #00ffff;
      text-shadow: 0 0 30px #00ffff;
      margin: 10px 0;
    }
    .final-best {
      font-size: clamp(14px, 3vw, 20px);
      color: #ffff00;
      text-shadow: 0 0 10px #ffff00;
      letter-spacing: 2px;
    }
    .new-best {
      font-size: clamp(16px, 3.5vw, 24px);
      color: #ff00ff;
      text-shadow: 0 0 15px #ff00ff;
      animation: pulse-text 0.5s ease-in-out infinite alternate;
      letter-spacing: 3px;
    }
    @keyframes pulse-text {
      from { opacity: 0.7; transform: scale(1); }
      to   { opacity: 1;   transform: scale(1.05); }
    }
    .combo-flash {
      position: absolute;
      font-size: clamp(20px, 5vw, 36px);
      font-weight: 900;
      color: #ff00ff;
      text-shadow: 0 0 20px #ff00ff;
      pointer-events: none;
      animation: combo-pop 0.7s ease-out forwards;
      letter-spacing: 2px;
    }
    @keyframes combo-pop {
      0%   { opacity: 1; transform: scale(0.5) translateY(0); }
      50%  { opacity: 1; transform: scale(1.3) translateY(-20px); }
      100% { opacity: 0; transform: scale(1)   translateY(-50px); }
    }
    .level-flash {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(24px, 6vw, 48px);
      font-weight: 900;
      color: #ffff00;
      text-shadow: 0 0 30px #ffff00;
      pointer-events: none;
      animation: level-pop 1.2s ease-out forwards;
      letter-spacing: 4px;
      white-space: nowrap;
    }
    @keyframes level-pop {
      0%   { opacity: 0; transform: translate(-50%,-50%) scale(0.5); }
      20%  { opacity: 1; transform: translate(-50%,-50%) scale(1.2); }
      60%  { opacity: 1; transform: translate(-50%,-50%) scale(1);   }
      100% { opacity: 0; transform: translate(-50%,-50%) scale(1.1); }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const COLORS = [
      { fill: '#00ffff', shadow: 'rgba(0,255,255,0.7)',   dark: 'rgba(0,255,255,0.15)' },
      { fill: '#ff00ff', shadow: 'rgba(255,0,255,0.7)',   dark: 'rgba(255,0,255,0.15)' },
      { fill: '#ffff00', shadow: 'rgba(255,255,0,0.7)',   dark: 'rgba(255,255,0,0.15)'  },
      { fill: '#ff6600', shadow: 'rgba(255,102,0,0.7)',   dark: 'rgba(255,102,0,0.15)'  },
      { fill: '#00ff88', shadow: 'rgba(0,255,136,0.7)',   dark: 'rgba(0,255,136,0.15)'  },
    ];

    const NODE_RADIUS          = 22;
    const BASE_LIFETIME        = 10000;  // 10 seconds base lifetime
    const MAX_LIVES            = 3;
    const INITIAL_SPAWN_INTERVAL = 2400;
    const STORAGE_KEY          = 'circuitBlazeHighScore';

    // ── Line-segment intersection ────────────────────────────
    function segmentsIntersect(ax, ay, bx, by, cx, cy, dx, dy) {
      const denom = (dx - cx) * (ay - by) - (dy - cy) * (ax - bx);
      if (Math.abs(denom) < 1e-10) return null;
      const t = ((dx - cx) * (ay - cy) - (dy - cy) * (ax - cx)) / denom;
      const u = ((ax - bx) * (ay - cy) - (ay - by) * (ax - cx)) / denom;
      if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
        return { x: ax + t * (bx - ax), y: ay + t * (by - ay) };
      }
      return null;
    }

    // ── Lightning helpers ────────────────────────────────────
    // Generate fixed midpoint offsets for a lightning bolt path
    function generateLightningPts(x1, y1, x2, y2, n) {
      const len = Math.hypot(x2 - x1, y2 - y1);
      const pts = [];
      for (let i = 1; i < n; i++) {
        pts.push({
          t: i / n,
          offset: (Math.random() - 0.5) * Math.max(len * 0.28, 12),
        });
      }
      return pts;
    }

    // Draw a multi-pass glowing lightning bolt
    function drawLightningLine(ctx, x1, y1, x2, y2, color, alpha, pts) {
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.hypot(dx, dy);
      if (len < 2) return;
      const perpX = -dy / len, perpY = dx / len;

      // Build path: fixed base + tiny per-frame jitter for flicker
      const px = [x1], py = [y1];
      pts.forEach(p => {
        const jitter = (Math.random() - 0.5) * len * 0.06;
        px.push(x1 + dx * p.t + perpX * (p.offset + jitter));
        py.push(y1 + dy * p.t + perpY * (p.offset + jitter));
      });
      px.push(x2); py.push(y2);

      const strokePath = () => {
        ctx.beginPath();
        ctx.moveTo(px[0], py[0]);
        for (let i = 1; i < px.length; i++) ctx.lineTo(px[i], py[i]);
        ctx.stroke();
      };

      ctx.save();
      ctx.lineJoin = 'round';
      ctx.lineCap  = 'round';

      // Outer glow
      ctx.globalAlpha = alpha * 0.14;
      ctx.strokeStyle = color;
      ctx.lineWidth   = 24;
      ctx.shadowColor = color;
      ctx.shadowBlur  = 45;
      strokePath();

      // Mid glow
      ctx.globalAlpha = alpha * 0.45;
      ctx.lineWidth   = 8;
      ctx.shadowBlur  = 20;
      strokePath();

      // Bright core (colored)
      ctx.globalAlpha = alpha * 0.85;
      ctx.lineWidth   = 2.5;
      ctx.shadowBlur  = 10;
      strokePath();

      // White-hot inner core
      ctx.globalAlpha = alpha * 0.95;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth   = 1;
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur  = 6;
      strokePath();

      ctx.restore();
    }

    function Heart({ filled }) {
      return (
        <svg className={`heart ${filled ? '' : 'lost'}`} viewBox="0 0 24 24" fill={filled ? '#ff4488' : '#444'}>
          <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
        </svg>
      );
    }

    const CircuitBlaze = () => {
      const canvasRef = useRef(null);
      const stateRef  = useRef(null);
      const rafRef    = useRef(null);
      const [ui, setUi] = useState({
        phase: 'intro',
        score: 0,
        combo: 0,
        lives: MAX_LIVES,
        highScore: parseInt(localStorage.getItem(STORAGE_KEY) || '0'),
        level: 1,
      });
      const [comboFlashes,   setComboFlashes]   = useState([]);
      const [showLevelFlash, setShowLevelFlash] = useState(null);

      if (!stateRef.current) {
        stateRef.current = {
          phase: 'intro',
          nodes: [],
          particles: [],
          connections: [],   // fading completed connections
          crossSparks: [],   // crossing spark effects
          score: 0,
          combo: 0,
          lives: MAX_LIVES,
          level: 1,
          highScore: parseInt(localStorage.getItem(STORAGE_KEY) || '0'),
          dragFrom: null,
          mouseX: 0,
          mouseY: 0,
          bgHue: 0,
          spawnTimer: 0,
          spawnInterval: INITIAL_SPAWN_INTERVAL,
          lifetimeMultiplier: 1.0,
          lastTime: null,
          audioCtx: null,
          nodeId: 0,
          levelUpScore: 500,
          isDragging: false,
        };
      }

      const S = stateRef.current;

      // ── Audio ────────────────────────────────────────────────
      const initAudio = useCallback(() => {
        if (!S.audioCtx) {
          S.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (S.audioCtx.state === 'suspended') S.audioCtx.resume();
      }, []);

      const playTone = useCallback((freq, type, dur, vol, freqEnd) => {
        if (!S.audioCtx) return;
        try {
          const osc  = S.audioCtx.createOscillator();
          const gain = S.audioCtx.createGain();
          osc.connect(gain);
          gain.connect(S.audioCtx.destination);
          osc.type = type || 'sine';
          osc.frequency.setValueAtTime(freq, S.audioCtx.currentTime);
          if (freqEnd) osc.frequency.exponentialRampToValueAtTime(freqEnd, S.audioCtx.currentTime + dur);
          gain.gain.setValueAtTime(vol || 0.3, S.audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, S.audioCtx.currentTime + (dur || 0.2));
          osc.start();
          osc.stop(S.audioCtx.currentTime + (dur || 0.2) + 0.01);
        } catch (e) {}
      }, []);

      const playConnect = useCallback((combo) => {
        const base = 440 + Math.min(combo - 1, 10) * 60;
        playTone(base,       'sine',     0.12, 0.4, base * 1.5);
        setTimeout(() => playTone(base * 1.5, 'sine',     0.10, 0.25, base * 2), 90);
        if (combo >= 3) setTimeout(() => playTone(base * 2,   'triangle', 0.15, 0.2), 180);
      }, [playTone]);

      const playExpire = useCallback(() => {
        playTone(180, 'sawtooth', 0.35, 0.25, 60);
      }, [playTone]);

      const playGameOver = useCallback(() => {
        playTone(300, 'sawtooth', 0.3, 0.4, 150);
        setTimeout(() => playTone(150, 'sawtooth', 0.4, 0.4, 80),  250);
        setTimeout(() => playTone(80,  'sawtooth', 0.7, 0.35, 40), 550);
      }, [playTone]);

      const playCross = useCallback(() => {
        playTone(600, 'triangle', 0.08, 0.15, 800);
      }, [playTone]);

      // ── Particles ────────────────────────────────────────────
      const spawnParticles = useCallback((x, y, colorIdx, count) => {
        const color = COLORS[colorIdx];
        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count + Math.random() * 0.8;
          const speed = 80 + Math.random() * 220;
          S.particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
            decay: 0.6 + Math.random() * 0.5,
            size: 2 + Math.random() * 6,
            color: color.fill,
            glow:  color.shadow,
          });
        }
      }, []);

      const spawnCrossSpark = useCallback((x, y) => {
        for (let i = 0; i < 8; i++) {
          const angle = (Math.PI * 2 * i) / 8 + Math.random() * 0.5;
          const speed = 40 + Math.random() * 80;
          S.crossSparks.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
            decay: 2.5 + Math.random(),
            size: 2 + Math.random() * 3,
          });
        }
      }, []);

      // ── Node spawning ────────────────────────────────────────
      const spawnNode = useCallback((canvas, forceColorIdx) => {
        const W = canvas.width;
        const H = canvas.height;
        const margin    = 80;
        const hudHeight = 65;

        let colorIdx;
        if (forceColorIdx !== undefined) {
          colorIdx = forceColorIdx;
        } else {
          const counts  = Array(COLORS.length).fill(0);
          S.nodes.forEach(n => counts[n.colorIdx]++);
          // odd = colors with an unpaired node (1, 3, 5)
          const oddOnes  = COLORS.map((_, i) => i).filter(i => counts[i] % 2 === 1 && counts[i] < 6);
          const evenOnes = COLORS.map((_, i) => i).filter(i => counts[i] % 2 === 0 && counts[i] < 6);
          if (oddOnes.length > 0) {
            colorIdx = Math.random() > 0.15
              ? oddOnes[Math.floor(Math.random() * oddOnes.length)]
              : (evenOnes.length > 0
                  ? evenOnes[Math.floor(Math.random() * evenOnes.length)]
                  : Math.floor(Math.random() * COLORS.length));
          } else {
            colorIdx = evenOnes.length > 0
              ? evenOnes[Math.floor(Math.random() * evenOnes.length)]
              : Math.floor(Math.random() * COLORS.length);
          }
        }

        let x, y, tries = 0;
        do {
          x = margin + Math.random() * (W - margin * 2);
          y = hudHeight + margin + Math.random() * (H - hudHeight - margin * 2);
          tries++;
        } while (tries < 30 && S.nodes.some(n => Math.hypot(n.x - x, n.y - y) < NODE_RADIUS * 3.5));

        const lifetime = BASE_LIFETIME * S.lifetimeMultiplier;
        S.nodes.push({
          id: ++S.nodeId,
          x, y,
          colorIdx,
          timeLeft: lifetime,
          maxTime:  lifetime,
          scale:   0,
          opacity: 0,
        });
      }, []);

      const ensurePairExists = useCallback((canvas) => {
        const counts = Array(COLORS.length).fill(0);
        S.nodes.forEach(n => counts[n.colorIdx]++);
        const hasAnyPair = counts.some(c => c >= 2);
        if (!hasAnyPair && S.nodes.length > 0) {
          const urgentNode = S.nodes.reduce((a, b) => a.timeLeft < b.timeLeft ? a : b);
          spawnNode(canvas, urgentNode.colorIdx);
        }
      }, [spawnNode]);

      // ── Drawing ──────────────────────────────────────────────
      const drawFrame = useCallback((timestamp) => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W   = canvas.width;
        const H   = canvas.height;

        const dt = S.lastTime ? Math.min((timestamp - S.lastTime) / 1000, 0.05) : 0.016;
        S.lastTime = timestamp;

        // ── Background ──
        S.bgHue = (S.bgHue + dt * 15) % 360;
        const grad = ctx.createRadialGradient(W * 0.5, H * 0.45, 0, W * 0.5, H * 0.5, Math.max(W, H) * 0.85);
        grad.addColorStop(0,   `hsla(${S.bgHue},           70%, 10%, 1)`);
        grad.addColorStop(0.5, `hsla(${(S.bgHue+100)%360}, 80%,  6%, 1)`);
        grad.addColorStop(1,   `hsla(${(S.bgHue+220)%360}, 90%,  4%, 1)`);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);

        // Grid dots
        ctx.fillStyle = 'rgba(255,255,255,0.04)';
        const gs = 50;
        for (let gx = gs; gx < W; gx += gs)
          for (let gy = gs; gy < H; gy += gs) {
            ctx.beginPath();
            ctx.arc(gx, gy, 1, 0, Math.PI * 2);
            ctx.fill();
          }

        if (S.phase === 'playing') {
          // ── Spawn nodes ──
          S.spawnTimer += dt * 1000;
          if (S.spawnTimer >= S.spawnInterval) {
            S.spawnTimer = 0;

            // 20% chance: spawn a QUAD (4 of same color) for multi-link chain combos
            const spawnCts = Array(COLORS.length).fill(0);
            S.nodes.forEach(n => spawnCts[n.colorIdx]++);
            const pairColors = COLORS.map((_, i) => i).filter(i => spawnCts[i] === 2);

            if (pairColors.length > 0 && Math.random() < 0.2) {
              // Extend an existing pair to a quad
              const ci = pairColors[Math.floor(Math.random() * pairColors.length)];
              spawnNode(canvas, ci);
              spawnNode(canvas, ci);
            } else {
              spawnNode(canvas);
              if (Math.random() < 0.25 + S.level * 0.05) spawnNode(canvas);
            }

            ensurePairExists(canvas);
          }

          // ── Update nodes ──
          const expiredNodes = [];
          S.nodes = S.nodes.filter(node => {
            node.timeLeft -= dt * 1000;
            node.scale   = Math.min(1, node.scale   + dt * 6);
            node.opacity = Math.min(1, node.opacity + dt * 6);
            if (node.timeLeft <= 0) {
              expiredNodes.push(node);
              return false;
            }
            return true;
          });

          // ── Handle expiry: 1 life lost per COLOR GROUP, not per node ──
          if (expiredNodes.length > 0) {
            // Particles for each expired node
            expiredNodes.forEach(node => {
              spawnParticles(node.x, node.y, node.colorIdx, 12);
            });

            // Sound: once per unique color that burned out
            const expiredColors = new Set(expiredNodes.map(n => n.colorIdx));
            expiredColors.forEach(() => playExpire());

            // Lives lost = number of UNIQUE colors (pairs treated as one failure)
            const livesLost = expiredColors.size;
            S.lives = Math.max(0, S.lives - livesLost);
            // NOTE: combo does NOT reset on expiry — only on wrong connections

            if (S.lives <= 0) {
              S.phase = 'gameover';
              if (S.score > S.highScore) {
                S.highScore = S.score;
                localStorage.setItem(STORAGE_KEY, S.score);
              }
              playGameOver();
              setUi(u => ({ ...u, phase: 'gameover', score: S.score, highScore: S.highScore, lives: 0 }));
            } else {
              setUi(u => ({ ...u, lives: S.lives }));
            }

            ensurePairExists(canvas);
          }

          // ── Level up ──
          const newLevel = 1 + Math.floor(S.score / 500);
          if (newLevel > S.level) {
            S.level = newLevel;
            S.spawnInterval        = Math.max(700, INITIAL_SPAWN_INTERVAL - (S.level - 1) * 180);
            S.lifetimeMultiplier   = Math.max(0.45, 1.0 - (S.level - 1) * 0.07);
            setShowLevelFlash(`LEVEL ${S.level}`);
            setTimeout(() => setShowLevelFlash(null), 1200);
            setUi(u => ({ ...u, level: S.level }));
          }
        }

        // ── Draw connections as lightning bolts (persist ~2 seconds) ──
        S.connections = S.connections.filter(c => {
          c.life -= dt * 0.5;   // slow fade: ~2 seconds visible
          if (c.life <= 0) return false;
          const col = COLORS[c.colorIdx];
          drawLightningLine(ctx, c.x1, c.y1, c.x2, c.y2, col.fill, c.life, c.pts);
          ctx.globalAlpha = 1;
          ctx.shadowBlur  = 0;
          return true;
        });

        // ── Drag line ──
        if (S.dragFrom && S.phase === 'playing') {
          const col = COLORS[S.dragFrom.node.colorIdx];
          const mx  = S.mouseX, my = S.mouseY;
          const nx  = S.dragFrom.node.x, ny = S.dragFrom.node.y;

          // Detect hover over a valid target
          let hoverTarget = null;
          S.nodes.forEach(node => {
            if (node.id === S.dragFrom.node.id) return;
            if (node.colorIdx === S.dragFrom.node.colorIdx) {
              if (Math.hypot(node.x - mx, node.y - my) < NODE_RADIUS * 2.5)
                hoverTarget = node;
            }
          });

          // Spawn cross-sparks where drag line crosses existing connections
          S.connections.forEach(c => {
            const pt = segmentsIntersect(nx, ny, mx, my, c.x1, c.y1, c.x2, c.y2);
            if (pt && Math.random() < 0.3) spawnCrossSpark(pt.x, pt.y);
          });

          // Draw drag line as a live flickering lightning bolt
          const livePts   = generateLightningPts(nx, ny, mx, my, 8);
          const dragAlpha = hoverTarget ? 0.95 : 0.75;
          drawLightningLine(ctx, nx, ny, mx, my, col.fill, dragAlpha, livePts);

          // Snap ring on hover target
          if (hoverTarget) {
            ctx.save();
            ctx.globalAlpha = 0.6 + 0.4 * Math.sin(timestamp * 0.015);
            ctx.strokeStyle = col.fill;
            ctx.lineWidth   = 3;
            ctx.shadowColor = col.fill;
            ctx.shadowBlur  = 20;
            ctx.beginPath();
            ctx.arc(hoverTarget.x, hoverTarget.y, NODE_RADIUS * 1.8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur  = 0;
            ctx.restore();
          }
        }

        // ── Draw nodes ──
        S.nodes.forEach(node => {
          const col     = COLORS[node.colorIdx];
          const ratio   = node.timeLeft / node.maxTime;
          const urgency = ratio < 0.3 ? 1 + (0.3 - ratio) * 4 : 1;
          const pulse   = 1 + 0.08 * Math.sin(timestamp * 0.006 + node.id * 1.5);
          const r       = NODE_RADIUS * node.scale * pulse;
          const selected     = S.dragFrom && S.dragFrom.node.id === node.id;
          const isHoverTarget = S.dragFrom && !selected
            && node.colorIdx === S.dragFrom.node.colorIdx
            && Math.hypot(node.x - S.mouseX, node.y - S.mouseY) < NODE_RADIUS * 2.5;

          ctx.save();
          ctx.translate(node.x, node.y);
          ctx.globalAlpha = node.opacity;

          // Countdown arc
          ctx.beginPath();
          ctx.arc(0, 0, r + 8, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * ratio);
          ctx.strokeStyle = col.fill;
          ctx.lineWidth   = 3;
          ctx.shadowColor = col.fill;
          ctx.shadowBlur  = 10 * urgency;
          ctx.stroke();
          ctx.shadowBlur  = 0;

          // Ambient glow halo
          const glowR = ctx.createRadialGradient(0, 0, r * 0.5, 0, 0, r * 2.5);
          glowR.addColorStop(0, col.dark);
          glowR.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = glowR;
          ctx.beginPath();
          ctx.arc(0, 0, r * 2.5, 0, Math.PI * 2);
          ctx.fill();

          // Node body
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI * 2);
          ctx.fillStyle   = 'rgba(0,0,0,0.85)';
          ctx.fill();
          ctx.strokeStyle = col.fill;
          ctx.lineWidth   = (selected || isHoverTarget) ? 4 : 2.5;
          ctx.shadowColor = col.fill;
          ctx.shadowBlur  = (selected || isHoverTarget) ? 28 * urgency : 15 * urgency;
          ctx.stroke();
          ctx.shadowBlur  = 0;

          // Inner core dot
          ctx.beginPath();
          ctx.arc(0, 0, r * 0.38, 0, Math.PI * 2);
          ctx.fillStyle   = col.fill;
          ctx.shadowColor = col.fill;
          ctx.shadowBlur  = 12;
          ctx.fill();
          ctx.shadowBlur  = 0;

          // Pulse ring when selected or hovered
          if (selected || isHoverTarget) {
            const ringR = isHoverTarget
              ? r + 18 + 6 * Math.abs(Math.sin(timestamp * 0.015))
              : r + 14 + 4 * Math.sin(timestamp * 0.012);
            ctx.beginPath();
            ctx.arc(0, 0, ringR, 0, Math.PI * 2);
            ctx.strokeStyle  = col.fill;
            ctx.lineWidth    = isHoverTarget ? 2.5 : 1.5;
            ctx.globalAlpha  = node.opacity * (isHoverTarget ? 0.7 : 0.5);
            ctx.stroke();
          }

          ctx.restore();
        });

        // ── Draw particles ──
        S.particles = S.particles.filter(p => {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= Math.pow(0.85, dt * 60);
          p.vy *= Math.pow(0.85, dt * 60);
          p.life -= dt * p.decay;
          if (p.life <= 0) return false;
          ctx.globalAlpha = p.life;
          ctx.fillStyle   = p.color;
          ctx.shadowColor = p.glow;
          ctx.shadowBlur  = 8;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
          ctx.fill();
          return true;
        });

        // ── Draw crossing sparks ──
        S.crossSparks = S.crossSparks.filter(s => {
          s.x += s.vx * dt;
          s.y += s.vy * dt;
          s.vx *= Math.pow(0.7, dt * 60);
          s.vy *= Math.pow(0.7, dt * 60);
          s.life -= dt * s.decay;
          if (s.life <= 0) return false;
          ctx.globalAlpha = s.life;
          ctx.fillStyle   = '#ffffff';
          ctx.shadowColor = '#ffffff';
          ctx.shadowBlur  = 6;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.size * s.life, 0, Math.PI * 2);
          ctx.fill();
          return true;
        });

        ctx.globalAlpha = 1;
        ctx.shadowBlur  = 0;

        rafRef.current = requestAnimationFrame(drawFrame);
      }, [spawnNode, ensurePairExists, spawnParticles, spawnCrossSpark, playExpire, playGameOver]);

      // ── Resize ───────────────────────────────────────────────
      useEffect(() => {
        const resize = () => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          canvas.width  = window.innerWidth;
          canvas.height = window.innerHeight;
        };
        resize();
        window.addEventListener('resize', resize);
        return () => window.removeEventListener('resize', resize);
      }, []);

      // ── Animation loop ───────────────────────────────────────
      useEffect(() => {
        rafRef.current = requestAnimationFrame(drawFrame);
        return () => { if (rafRef.current) cancelAnimationFrame(rafRef.current); };
      }, [drawFrame]);

      // ── Game start ───────────────────────────────────────────
      const startGame = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        S.phase              = 'playing';
        S.nodes              = [];
        S.particles          = [];
        S.connections        = [];
        S.crossSparks        = [];
        S.score              = 0;
        S.combo              = 0;
        S.lives              = MAX_LIVES;
        S.level              = 1;
        S.spawnTimer         = 0;
        S.spawnInterval      = INITIAL_SPAWN_INTERVAL;
        S.lifetimeMultiplier = 1.0;
        S.dragFrom           = null;
        S.isDragging         = false;
        S.lastTime           = null;
        S.nodeId             = 0;

        // Seed with 2 guaranteed pairs
        const c1 = Math.floor(Math.random() * COLORS.length);
        const c2 = (c1 + 1 + Math.floor(Math.random() * (COLORS.length - 1))) % COLORS.length;
        spawnNode(canvas, c1);
        spawnNode(canvas, c2);
        spawnNode(canvas, c1);
        spawnNode(canvas, c2);

        // Stagger initial lifetimes so they don't all expire simultaneously
        S.nodes.forEach(n => {
          const stagger = Math.random() * 3500;   // 0–3.5 s offset
          n.timeLeft = Math.max(4000, n.timeLeft - stagger);
          n.maxTime  = n.timeLeft;
        });

        setUi({ phase: 'playing', score: 0, combo: 0, lives: MAX_LIVES, highScore: S.highScore, level: 1 });
        setComboFlashes([]);
        setShowLevelFlash(null);
      }, [spawnNode]);

      // ── Node hit test ────────────────────────────────────────
      const getNodeAt = useCallback((x, y) => {
        let closest = null, closestDist = NODE_RADIUS * 2.0;
        S.nodes.forEach(n => {
          const d = Math.hypot(n.x - x, n.y - y);
          if (d < closestDist) { closestDist = d; closest = n; }
        });
        return closest;
      }, []);

      // ── Pointer position ─────────────────────────────────────
      const getPos = useCallback((e) => {
        const canvas = canvasRef.current;
        if (!canvas) return { x: 0, y: 0 };
        const rect = canvas.getBoundingClientRect();
        const sx = canvas.width  / rect.width;
        const sy = canvas.height / rect.height;
        let src;
        if (e.changedTouches && e.changedTouches.length > 0) src = e.changedTouches[0];
        else if (e.touches   && e.touches.length   > 0) src = e.touches[0];
        else src = e;
        return { x: (src.clientX - rect.left) * sx, y: (src.clientY - rect.top) * sy };
      }, []);

      // ── Connection logic ─────────────────────────────────────
      const tryConnect = useCallback((x, y) => {
        if (!S.dragFrom || S.phase !== 'playing') {
          S.dragFrom  = null;
          S.isDragging = false;
          return;
        }

        const target = getNodeAt(x, y);

        if (target && target.id !== S.dragFrom.node.id && target.colorIdx === S.dragFrom.node.colorIdx) {
          // ── Successful connection! ──
          S.combo++;
          const points = 100 * S.combo;
          S.score += points;

          // Store connection flash as lightning with persistent path points
          S.connections.push({
            x1: S.dragFrom.node.x, y1: S.dragFrom.node.y,
            x2: target.x,          y2: target.y,
            colorIdx: target.colorIdx,
            life: 1,
            pts: generateLightningPts(S.dragFrom.node.x, S.dragFrom.node.y, target.x, target.y, 10),
          });

          // Check crossings with existing connections → bonus sparks
          S.connections.forEach(c => {
            if (c.life >= 1) return; // skip the just-added one
            const pt = segmentsIntersect(
              S.dragFrom.node.x, S.dragFrom.node.y, target.x, target.y,
              c.x1, c.y1, c.x2, c.y2
            );
            if (pt) {
              spawnCrossSpark(pt.x, pt.y);
              spawnCrossSpark(pt.x, pt.y);
              playCross();
            }
          });

          // Burst particles at both endpoints
          spawnParticles(S.dragFrom.node.x, S.dragFrom.node.y, S.dragFrom.node.colorIdx, 22);
          spawnParticles(target.x, target.y, target.colorIdx, 22);

          // Sparkle particles along the connection path
          for (let t = 0.2; t < 0.95; t += 0.2) {
            const px = S.dragFrom.node.x + (target.x - S.dragFrom.node.x) * t;
            const py = S.dragFrom.node.y + (target.y - S.dragFrom.node.y) * t;
            spawnParticles(px, py, target.colorIdx, 8);
          }

          // Remove connected nodes
          S.nodes = S.nodes.filter(n => n.id !== S.dragFrom.node.id && n.id !== target.id);

          playConnect(S.combo);

          if (S.combo >= 2) {
            const flashId = Date.now() + Math.random();
            const midX    = (S.dragFrom.node.x + target.x) / 2;
            const midY    = (S.dragFrom.node.y + target.y) / 2;
            setComboFlashes(prev => [...prev, { id: flashId, x: midX, y: midY, combo: S.combo }]);
            setTimeout(() => setComboFlashes(prev => prev.filter(f => f.id !== flashId)), 800);
          }

          setUi(u => ({ ...u, score: S.score, combo: S.combo }));

          const canvas = canvasRef.current;
          if (canvas) setTimeout(() => ensurePairExists(canvas), 100);

        } else if (target && target.id !== S.dragFrom.node.id) {
          // Wrong color — break combo
          S.combo = 0;
          setUi(u => ({ ...u, combo: 0 }));
        }

        S.dragFrom   = null;
        S.isDragging = false;
      }, [getNodeAt, spawnParticles, spawnCrossSpark, playConnect, playCross, ensurePairExists]);

      // ── Input handlers ───────────────────────────────────────
      const handlePointerDown = useCallback((e) => {
        e.preventDefault();
        initAudio();
        const { x, y } = getPos(e);
        S.mouseX = x; S.mouseY = y;

        if (S.phase !== 'playing') { startGame(); return; }

        const node = getNodeAt(x, y);
        if (node) {
          S.dragFrom   = { node, startX: x, startY: y };
          S.isDragging = true;
        }
      }, [initAudio, getPos, startGame, getNodeAt]);

      const handlePointerMove = useCallback((e) => {
        e.preventDefault();
        const { x, y } = getPos(e);
        S.mouseX = x; S.mouseY = y;
      }, [getPos]);

      const handlePointerUp = useCallback((e) => {
        if (e.preventDefault) e.preventDefault();
        const { x, y } = getPos(e);
        tryConnect(x, y);
      }, [getPos, tryConnect]);

      // ── Global drag-release fallback ─────────────────────────
      useEffect(() => {
        const onMouseUp  = (e) => { if (S.isDragging) handlePointerUp(e); };
        const onTouchEnd = (e) => { if (S.isDragging) handlePointerUp(e); };
        window.addEventListener('mouseup',  onMouseUp);
        window.addEventListener('touchend', onTouchEnd, { passive: false });
        return () => {
          window.removeEventListener('mouseup',  onMouseUp);
          window.removeEventListener('touchend', onTouchEnd);
        };
      }, [handlePointerUp]);

      // ── Keyboard ─────────────────────────────────────────────
      useEffect(() => {
        const onKey = (e) => {
          if ((e.code === 'Space' || e.code === 'Enter') && S.phase !== 'playing') {
            initAudio(); startGame();
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [initAudio, startGame]);

      // ── Render ───────────────────────────────────────────────
      const isNewBest = ui.phase === 'gameover' && ui.score > 0 && ui.score >= ui.highScore;

      return (
        <div style={{ width: '100vw', height: '100vh', position: 'relative' }}>
          <canvas
            ref={canvasRef}
            style={{ display: 'block', width: '100%', height: '100%' }}
            onMouseDown={handlePointerDown}
            onMouseMove={handlePointerMove}
            onMouseUp={handlePointerUp}
            onTouchStart={handlePointerDown}
            onTouchMove={handlePointerMove}
            onTouchEnd={handlePointerUp}
          />

          {/* HUD */}
          {ui.phase === 'playing' && (
            <div className="hud">
              <div className="hud-block">
                <div className="hud-label">Score</div>
                <div className="hud-value hud-score">{ui.score}</div>
              </div>
              <div className="hud-block">
                <div className="hud-label">Lives</div>
                <div className="lives">
                  {[0,1,2].map(i => <Heart key={i} filled={i < ui.lives} />)}
                </div>
              </div>
              <div className="hud-block">
                <div className="hud-label">Combo</div>
                <div className="hud-value hud-combo">x{ui.combo}</div>
              </div>
              <div className="hud-block">
                <div className="hud-label">Best</div>
                <div className="hud-value hud-best">{ui.highScore}</div>
              </div>
            </div>
          )}

          {/* Combo flashes */}
          {comboFlashes.map(f => (
            <div
              key={f.id}
              className="combo-flash"
              style={{ left: f.x, top: f.y, transform: 'translate(-50%,-50%)' }}
            >
              x{f.combo} COMBO!
            </div>
          ))}

          {/* Level flash */}
          {showLevelFlash && <div className="level-flash">{showLevelFlash}</div>}

          {/* Intro */}
          {ui.phase === 'intro' && (
            <div className="screen" onMouseDown={handlePointerDown} onTouchStart={handlePointerDown}>
              <div className="title">CIRCUIT BLAZE</div>
              <div className="subtitle">Connect matching nodes before they expire</div>
              <div className="instructions">
                <div className="inst-row"><span>DRAG</span> from one node to a same-color node</div>
                <div className="inst-row">Build <span>COMBOS</span> — connect chains of 4 for big multipliers</div>
                <div className="inst-row">A <span>PAIR</span> burning out costs only <span>1 LIFE</span></div>
                <div className="inst-row">Cross connections for <span>LIGHTNING SPARKS!</span></div>
              </div>
              <button className="start-btn" onMouseDown={e => { e.stopPropagation(); handlePointerDown(e); }}>
                IGNITE
              </button>
              {ui.highScore > 0 && (
                <div style={{ marginTop: 20, color: '#ffff00', textShadow: '0 0 10px #ffff00', fontSize: 14, letterSpacing: 2 }}>
                  BEST: {ui.highScore}
                </div>
              )}
            </div>
          )}

          {/* Game Over */}
          {ui.phase === 'gameover' && (
            <div className="screen" onMouseDown={handlePointerDown} onTouchStart={handlePointerDown}>
              <div style={{ fontSize: 'clamp(16px,4vw,28px)', color: '#ff4488', letterSpacing: 4, textShadow: '0 0 15px #ff4488' }}>
                CIRCUIT BROKEN
              </div>
              <div className="final-score">{ui.score}</div>
              {isNewBest ? (
                <div className="new-best">✦ NEW BEST ✦</div>
              ) : (
                <div className="final-best">BEST: {ui.highScore}</div>
              )}
              <button
                className="start-btn"
                style={{ marginTop: 30, borderColor: '#ff00ff', color: '#ff00ff', boxShadow: '0 0 20px rgba(255,0,255,0.3)' }}
                onMouseDown={e => { e.stopPropagation(); handlePointerDown(e); }}
              >
                RETRY
              </button>
            </div>
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CircuitBlaze />);
  </script>
</body>
</html>
