<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vortex Shift</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    #root { width: 100vw; height: 100vh; }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.25; }
    }
    @keyframes pulse-glow {
      0%, 100% { text-shadow: 0 0 20px #8800ff, 0 0 40px #8800ff; }
      50% { text-shadow: 0 0 40px #cc00ff, 0 0 80px #cc00ff, 0 0 120px #8800ff; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const HS_KEY = 'vortexShiftHighScore';
    const TWO_PI = Math.PI * 2;

    // ─── Audio helpers ───────────────────────────────────────────────────────────
    function playTone(ctx, freq1, freq2, dur, type = 'sine', vol = 0.18) {
      if (!ctx) return;
      try {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.setValueAtTime(freq1, ctx.currentTime);
        if (freq2 !== freq1) {
          osc.frequency.exponentialRampToValueAtTime(freq2, ctx.currentTime + dur);
        }
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + dur + 0.01);
      } catch (e) {}
    }

    // ─── Drawing helpers ─────────────────────────────────────────────────────────
    function drawVortex(ctx, cx, cy, angle) {
      ctx.save();
      ctx.translate(cx, cy);
      // Spinning spokes
      for (let i = 0; i < 8; i++) {
        const a = angle * 1.8 + (i / 8) * TWO_PI;
        const r1 = 5, r2 = 26;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a) * r1, Math.sin(a) * r1);
        ctx.lineTo(Math.cos(a + 0.35) * r2, Math.sin(a + 0.35) * r2);
        ctx.strokeStyle = `hsla(${(i * 45 + angle * 80) % 360}, 100%, 72%, 0.95)`;
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
      // Center glow
      const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
      grd.addColorStop(0, 'rgba(255, 120, 255, 0.95)');
      grd.addColorStop(0.4, 'rgba(120, 0, 255, 0.6)');
      grd.addColorStop(1, 'rgba(0, 0, 80, 0)');
      ctx.beginPath();
      ctx.arc(0, 0, 30, 0, TWO_PI);
      ctx.fillStyle = grd;
      ctx.fill();
      ctx.restore();
    }

    function drawOrb(ctx, x, y, color) {
      // Outer glow halo
      const grd = ctx.createRadialGradient(x, y, 0, x, y, 22);
      grd.addColorStop(0, color + 'cc');
      grd.addColorStop(0.5, color + '50');
      grd.addColorStop(1, color + '00');
      ctx.beginPath();
      ctx.arc(x, y, 22, 0, TWO_PI);
      ctx.fillStyle = grd;
      ctx.fill();
      // White core
      ctx.beginPath();
      ctx.arc(x, y, 6, 0, TWO_PI);
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = color;
      ctx.shadowBlur = 20;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawBarrierArc(ctx, cx, cy, radius, gapAngle, gapSize, hue) {
      ctx.save();
      ctx.translate(cx, cy);
      // Arc covers the NON-gap portion: from (gapAngle + gapSize) clockwise to (gapAngle + 2π)
      const arcStart = gapAngle + gapSize;
      const arcEnd   = gapAngle + TWO_PI;

      // Outer bloom glow
      ctx.beginPath();
      ctx.arc(0, 0, radius, arcStart, arcEnd);
      ctx.strokeStyle = `hsla(${hue}, 100%, 65%, 0.2)`;
      ctx.lineWidth = 22;
      ctx.stroke();

      // Mid glow
      ctx.beginPath();
      ctx.arc(0, 0, radius, arcStart, arcEnd);
      ctx.strokeStyle = `hsla(${hue}, 100%, 65%, 0.35)`;
      ctx.lineWidth = 12;
      ctx.stroke();

      // Solid barrier
      ctx.beginPath();
      ctx.arc(0, 0, radius, arcStart, arcEnd);
      ctx.strokeStyle = `hsl(${hue}, 100%, 62%)`;
      ctx.lineWidth = 6;
      ctx.stroke();

      // Bright gap-edge dots (navigation hints)
      [gapAngle, gapAngle + gapSize].forEach(a => {
        const ex = Math.cos(a) * radius;
        const ey = Math.sin(a) * radius;
        ctx.beginPath();
        ctx.arc(ex, ey, 5, 0, TWO_PI);
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = `hsl(${hue}, 100%, 80%)`;
        ctx.shadowBlur = 14;
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      ctx.restore();
    }

    // ─── Main Component ──────────────────────────────────────────────────────────
    function VortexShift() {
      const canvasRef = useRef(null);
      const gsRef    = useRef({ phase: 'menu', frame: 0 });
      const rafRef   = useRef(null);
      const audioRef = useRef(null);

      const [ui, setUi] = useState(() => {
        const hs = Number(localStorage.getItem(HS_KEY) || 0);
        // Ensure key exists in localStorage so tests can detect it
        localStorage.setItem(HS_KEY, String(hs));
        return { phase: 'menu', score: 0, highScore: hs, combo: 0, isNewBest: false };
      });

      // ── Build fresh game state ──────────────────────────────────────────────
      function makeGameState() {
        const canvas = canvasRef.current;
        const W = canvas ? canvas.width  : window.innerWidth;
        const H = canvas ? canvas.height : window.innerHeight;
        const minR = Math.min(W, H) * 0.09;
        const maxR = Math.min(W, H) * 0.43;
        return {
          phase: 'playing',
          frame: 0,
          score: 0,
          combo: 0,
          nearMissCooldown: 0,
          flashMsg: '',
          flashTimer: 0,
          minR, maxR,
          player: {
            angle: 0,
            radius: (minR + maxR) / 2,
            direction: 1,   // +1 = outward, -1 = inward
            trail: [],
          },
          barriers: [],
          particles: [],
        };
      }

      // ── Spawn one barrier ───────────────────────────────────────────────────
      function spawnBarrier(gs) {
        const { minR, maxR, player, barriers, frame } = gs;
        let r, tries = 0;
        do {
          r = minR + 18 + Math.random() * (maxR - minR - 36);
          tries++;
        } while (
          tries < 20 &&
          (Math.abs(r - player.radius) < (maxR - minR) * 0.18 ||
           barriers.some(b => Math.abs(b.radius - r) < 24))
        );

        const diff = 1 + frame / 5000;
        const gapFrac = Math.max(0.17, 0.5 - diff * 0.045);
        const gapSize = TWO_PI * gapFrac;
        const rotDir  = Math.random() > 0.5 ? 1 : -1;
        const rotSpd  = (0.006 + Math.random() * 0.013) * diff * rotDir;
        const hue     = 260 + Math.random() * 110; // purple → pink → red

        gs.barriers.push({
          radius: r,
          gapAngle: Math.random() * TWO_PI,
          gapSize,
          rotSpd,
          hue,
        });
      }

      // ── Input: click / tap / keyboard ──────────────────────────────────────
      const handleInput = useCallback(() => {
        // Lazily create AudioContext on first gesture
        if (!audioRef.current) {
          try {
            audioRef.current = new (window.AudioContext || window.webkitAudioContext)();
          } catch (e) {}
        }

        const gs = gsRef.current;

        // Start / restart
        if (gs.phase === 'menu' || gs.phase === 'gameover') {
          gsRef.current = makeGameState();
          spawnBarrier(gsRef.current); // first barrier right away
          setUi(prev => ({
            ...prev,
            phase: 'playing',
            score: 0,
            combo: 0,
            isNewBest: false,
          }));
          return;
        }

        // Flip spiral direction while playing
        if (gs.phase === 'playing') {
          gs.player.direction *= -1;
          // Pitch up if going out, down if going in
          playTone(audioRef.current,
            gs.player.direction > 0 ? 220 : 550,
            gs.player.direction > 0 ? 660 : 180,
            0.14, 'sine', 0.18);

          // Burst particles at player position
          const canvas = canvasRef.current;
          if (canvas) {
            const cx = canvas.width / 2, cy = canvas.height / 2;
            const px = cx + Math.cos(gs.player.angle) * gs.player.radius;
            const py = cy + Math.sin(gs.player.angle) * gs.player.radius;
            for (let i = 0; i < 10; i++) {
              const a = Math.random() * TWO_PI;
              const spd = 2 + Math.random() * 4;
              gs.particles.push({
                x: px, y: py,
                vx: Math.cos(a) * spd,
                vy: Math.sin(a) * spd,
                life: 1,
                color: gs.player.direction > 0 ? '#00ffcc' : '#ff44ff',
              });
            }
          }
        }
      }, []); // eslint-disable-line react-hooks/exhaustive-deps

      // ── Canvas + game loop ──────────────────────────────────────────────────
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        function resize() {
          canvas.width  = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        let menuAngle = 0;

        function loop() {
          const ctx = canvas.getContext('2d');
          const W = canvas.width, H = canvas.height;
          const cx = W / 2, cy = H / 2;
          const gs = gsRef.current;

          // ── Background ───────────────────────────────────────────────────
          ctx.fillStyle = '#050012';
          ctx.fillRect(0, 0, W, H);

          // Scrolling grid
          ctx.save();
          const gSize = 52;
          const gOff  = ((gs.frame || 0) * 0.35) % gSize;
          ctx.strokeStyle = 'rgba(45, 18, 100, 0.22)';
          ctx.lineWidth = 0.5;
          for (let x = -gOff; x < W + gSize; x += gSize) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
          }
          for (let y = -gOff; y < H + gSize; y += gSize) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
          }
          ctx.restore();

          // ── MENU ─────────────────────────────────────────────────────────
          if (gs.phase === 'menu') {
            menuAngle += 0.02;
            const demoMinR = Math.min(W, H) * 0.09;
            const demoMaxR = Math.min(W, H) * 0.43;

            // Orbit rings
            [0.25, 0.5, 0.75, 1].forEach(f => {
              ctx.beginPath();
              ctx.arc(cx, cy, demoMinR + (demoMaxR - demoMinR) * f, 0, TWO_PI);
              ctx.strokeStyle = 'rgba(80, 50, 170, 0.18)';
              ctx.lineWidth = 1;
              ctx.stroke();
            });

            // Demo barriers (static-ish, just for aesthetics)
            drawBarrierArc(ctx, cx, cy, demoMinR + (demoMaxR - demoMinR) * 0.33,
              menuAngle * 0.4, Math.PI * 1.15, 290);
            drawBarrierArc(ctx, cx, cy, demoMinR + (demoMaxR - demoMinR) * 0.68,
              -menuAngle * 0.55, Math.PI * 1.35, 330);

            // Demo player spiraling
            const demoR = (demoMinR + demoMaxR) / 2 +
              Math.sin(menuAngle * 0.65) * (demoMaxR - demoMinR) * 0.28;
            const dmx = cx + Math.cos(menuAngle) * demoR;
            const dmy = cy + Math.sin(menuAngle) * demoR;
            drawOrb(ctx, dmx, dmy, '#00ffcc');

            drawVortex(ctx, cx, cy, menuAngle);

            rafRef.current = requestAnimationFrame(loop);
            return;
          }

          // ── GAME OVER ─────────────────────────────────────────────────────
          if (gs.phase === 'gameover') {
            // Let particles keep animating
            gs.particles = gs.particles.filter(p => p.life > 0);
            gs.particles.forEach(p => {
              p.x += p.vx; p.y += p.vy;
              p.vx *= 0.93; p.vy *= 0.93;
              p.life -= 0.018;
              ctx.save();
              ctx.globalAlpha = Math.max(0, p.life);
              ctx.beginPath();
              ctx.arc(p.x, p.y, Math.max(0, 5 * p.life), 0, TWO_PI);
              ctx.fillStyle = p.color;
              ctx.fill();
              ctx.restore();
            });
            drawVortex(ctx, cx, cy, Date.now() * 0.001);
            rafRef.current = requestAnimationFrame(loop);
            return;
          }

          // ── PLAYING ───────────────────────────────────────────────────────
          gs.frame++;
          const diff    = 1 + gs.frame / 5500;
          const angSpd  = 0.021 * diff;
          const spirSpd = Math.min(W, H) * 0.00145 * diff;

          // Move player
          gs.player.angle  += angSpd;
          gs.player.radius += gs.player.direction * spirSpd;

          // Bounce at walls (walls safe, only barriers kill)
          if (gs.player.radius >= gs.maxR) {
            gs.player.radius = gs.maxR;
            gs.player.direction = -1;
          } else if (gs.player.radius <= gs.minR) {
            gs.player.radius = gs.minR;
            gs.player.direction = 1;
          }

          // Rotate barrier gaps
          gs.barriers.forEach(b => { b.gapAngle += b.rotSpd; });

          // Spawn barriers over time
          const target = Math.min(1 + Math.floor(gs.frame / 220), 7);
          if (gs.barriers.length < target && gs.frame % 200 === 0) spawnBarrier(gs);

          // Scoring (10 pts/sec)
          gs.score = Math.floor(gs.frame / 60) * 10;

          // Near-miss cooldown
          if (gs.nearMissCooldown > 0) gs.nearMissCooldown--;

          // ── Collision detection ────────────────────────────────────────
          let dead = false;
          for (const b of gs.barriers) {
            if (dead) break;
            const dist = Math.abs(gs.player.radius - b.radius);
            if (dist < 11) {
              // Normalize player angle relative to gap start
              const relAng = ((gs.player.angle - b.gapAngle) % TWO_PI + TWO_PI) % TWO_PI;
              if (relAng >= b.gapSize) {
                dead = true; // barrier hit
              } else if (gs.nearMissCooldown === 0) {
                // Near miss if player is close to gap edge
                const edgeFrac = Math.min(relAng / b.gapSize, (b.gapSize - relAng) / b.gapSize);
                if (edgeFrac < 0.13) {
                  gs.combo++;
                  gs.nearMissCooldown = 50;
                  gs.flashMsg  = gs.combo > 2 ? `NEAR MISS ×${gs.combo}!` : 'NEAR MISS!';
                  gs.flashTimer = 72;
                  playTone(audioRef.current, 750, 380, 0.12, 'sine', 0.12);
                  setUi(prev => ({ ...prev, combo: gs.combo }));
                }
              }
            }
          }

          if (dead) {
            // Death sound
            playTone(audioRef.current, 380, 45, 0.65, 'sawtooth', 0.38);

            // Death particle explosion
            const px = cx + Math.cos(gs.player.angle) * gs.player.radius;
            const py = cy + Math.sin(gs.player.angle) * gs.player.radius;
            for (let i = 0; i < 45; i++) {
              const a   = Math.random() * TWO_PI;
              const spd = 2 + Math.random() * 9;
              const h   = Math.random() * 70; // red-orange-yellow
              gs.particles.push({
                x: px, y: py,
                vx: Math.cos(a) * spd,
                vy: Math.sin(a) * spd,
                life: 1,
                color: `hsl(${h}, 100%, 60%)`,
              });
            }

            const prevHS = Number(localStorage.getItem(HS_KEY) || 0);
            const newHS  = Math.max(gs.score, prevHS);
            localStorage.setItem(HS_KEY, String(newHS));
            gs.phase = 'gameover';
            setUi({
              phase: 'gameover',
              score: gs.score,
              highScore: newHS,
              combo: gs.combo,
              isNewBest: gs.score > prevHS && gs.score > 0,
            });
            rafRef.current = requestAnimationFrame(loop);
            return;
          }

          // Update particles
          gs.particles = gs.particles.filter(p => p.life > 0);
          gs.particles.forEach(p => {
            p.x += p.vx; p.y += p.vy;
            p.vx *= 0.94; p.vy *= 0.94;
            p.life -= 0.024;
          });

          // Update trail
          const px = cx + Math.cos(gs.player.angle) * gs.player.radius;
          const py = cy + Math.sin(gs.player.angle) * gs.player.radius;
          gs.player.trail.push({ x: px, y: py, dir: gs.player.direction });
          if (gs.player.trail.length > 30) gs.player.trail.shift();

          // ── Draw ─────────────────────────────────────────────────────
          // Faint orbit rings
          ctx.save();
          for (let r = gs.minR; r <= gs.maxR; r += (gs.maxR - gs.minR) / 5) {
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, TWO_PI);
            ctx.strokeStyle = 'rgba(65, 35, 140, 0.14)';
            ctx.lineWidth = 1;
            ctx.stroke();
          }
          ctx.restore();

          // Barriers
          gs.barriers.forEach(b => {
            drawBarrierArc(ctx, cx, cy, b.radius, b.gapAngle, b.gapSize, b.hue);
          });

          // Trail
          gs.player.trail.forEach((tp, i) => {
            const alpha = (i / gs.player.trail.length) * 0.65;
            const clr   = tp.dir > 0
              ? `rgba(0, 255, 200, ${alpha})`
              : `rgba(255, 60, 255, ${alpha})`;
            ctx.beginPath();
            ctx.arc(tp.x, tp.y, 6 * (i / gs.player.trail.length), 0, TWO_PI);
            ctx.fillStyle = clr;
            ctx.fill();
          });

          // Particles
          gs.particles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = Math.max(0, p.life);
            ctx.beginPath();
            ctx.arc(p.x, p.y, Math.max(0, 4.5 * p.life), 0, TWO_PI);
            ctx.fillStyle = p.color;
            ctx.fill();
            ctx.restore();
          });

          // Vortex center
          drawVortex(ctx, cx, cy, gs.frame * 0.038);

          // Player orb (cyan = outward, magenta = inward)
          const orbColor = gs.player.direction > 0 ? '#00ffcc' : '#ff44ff';
          drawOrb(ctx, px, py, orbColor);

          // Direction hint text
          ctx.save();
          ctx.font = `${Math.min(W, H) * 0.028}px Courier New`;
          ctx.fillStyle = orbColor;
          ctx.textAlign = 'center';
          ctx.shadowColor = orbColor;
          ctx.shadowBlur = 12;
          const hintX = cx + (gs.player.direction > 0 ? 1 : -1) * (gs.maxR + 28);
          ctx.fillText(gs.player.direction > 0 ? '▶' : '◀', hintX, cy + 6);
          ctx.restore();

          // Flash message (near miss, etc.)
          if (gs.flashTimer > 0) {
            gs.flashTimer--;
            const alpha = Math.min(1, gs.flashTimer / 30);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.font = `bold ${Math.min(W, H) * 0.038}px Courier New`;
            ctx.fillStyle = '#ffff44';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 28;
            ctx.fillText(gs.flashMsg, cx, cy - gs.minR - 20);
            ctx.restore();
          }

          // Score (on canvas for smooth render)
          ctx.save();
          ctx.font = `bold ${Math.min(W, H) * 0.058}px Courier New`;
          ctx.fillStyle = '#00ffcc';
          ctx.textAlign = 'center';
          ctx.shadowColor = '#00ffcc';
          ctx.shadowBlur = 22;
          ctx.fillText(gs.score, cx, 52);
          ctx.restore();

          // Combo (on canvas)
          if (gs.combo > 0) {
            ctx.save();
            ctx.font = `${Math.min(W, H) * 0.026}px Courier New`;
            ctx.fillStyle = '#ffff44';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 14;
            ctx.fillText(`COMBO ×${gs.combo}`, cx, 82);
            ctx.restore();
          }

          rafRef.current = requestAnimationFrame(loop);
        }

        rafRef.current = requestAnimationFrame(loop);

        return () => {
          cancelAnimationFrame(rafRef.current);
          window.removeEventListener('resize', resize);
        };
      }, []); // eslint-disable-line react-hooks/exhaustive-deps

      // ── Keyboard input ──────────────────────────────────────────────────────
      useEffect(() => {
        const onKey = e => {
          if (['Space', 'ArrowUp', 'ArrowDown', 'Enter', 'KeyW', 'KeyS'].includes(e.code)) {
            e.preventDefault();
            handleInput();
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [handleInput]);

      const { phase, score, highScore, isNewBest } = ui;
      const fs = Math.min(window.innerWidth, window.innerHeight);

      return (
        <div style={{ position: 'relative', width: '100vw', height: '100vh', overflow: 'hidden' }}>
          <canvas ref={canvasRef} style={{ display: 'block' }} />

          {/* ── Menu overlay ── */}
          {phase === 'menu' && (
            <div style={{
              position: 'absolute', inset: 0,
              display: 'flex', flexDirection: 'column',
              alignItems: 'center', justifyContent: 'center',
              pointerEvents: 'none',
            }}>
              <div style={{
                color: '#fff',
                fontSize: `${fs * 0.072}px`,
                fontWeight: 'bold',
                letterSpacing: 9,
                animation: 'pulse-glow 2.5s ease-in-out infinite',
                marginBottom: 14,
              }}>
                VORTEX SHIFT
              </div>
              <div style={{
                color: '#aa88ee',
                fontSize: `${fs * 0.026}px`,
                textAlign: 'center',
                lineHeight: 2,
                marginBottom: 38,
                letterSpacing: 2,
              }}>
                Spiral through neon barriers<br />
                <span style={{ color: '#00ffcc', fontWeight: 'bold' }}>
                  Click · Tap · Space
                </span>{' '}
                to flip direction
              </div>
              {highScore > 0 && (
                <div style={{
                  color: '#ffcc00',
                  fontSize: `${fs * 0.028}px`,
                  marginBottom: 30,
                  textShadow: '0 0 18px #ffcc00',
                  letterSpacing: 5,
                }}>
                  BEST: {highScore}
                </div>
              )}
              <div style={{
                color: '#ffffff',
                fontSize: `${fs * 0.032}px`,
                letterSpacing: 7,
                textShadow: '0 0 22px #fff',
                animation: 'blink 1.3s ease-in-out infinite',
              }}>
                CLICK TO BEGIN
              </div>
            </div>
          )}

          {/* ── Game Over overlay ── */}
          {phase === 'gameover' && (
            <div style={{
              position: 'absolute', inset: 0,
              display: 'flex', flexDirection: 'column',
              alignItems: 'center', justifyContent: 'center',
              background: 'rgba(0,0,0,0.58)',
              pointerEvents: 'none',
            }}>
              <div style={{
                color: '#ff4455',
                fontSize: `${fs * 0.068}px`,
                fontWeight: 'bold',
                textShadow: '0 0 30px #ff0020, 0 0 60px #ff0020',
                letterSpacing: 8,
                marginBottom: 22,
              }}>
                ABSORBED
              </div>
              <div style={{
                color: '#00ffcc',
                fontSize: `${fs * 0.072}px`,
                textShadow: '0 0 28px #00ffcc',
                letterSpacing: 5,
                marginBottom: 12,
              }}>
                {score}
              </div>
              {isNewBest && score > 0 && (
                <div style={{
                  color: '#ffff00',
                  fontSize: `${fs * 0.03}px`,
                  textShadow: '0 0 22px #ffff00',
                  marginBottom: 10,
                  animation: 'blink 0.75s infinite',
                  letterSpacing: 4,
                }}>
                  NEW BEST!
                </div>
              )}
              <div style={{
                color: '#7755aa',
                fontSize: `${fs * 0.022}px`,
                marginBottom: 34,
                letterSpacing: 4,
              }}>
                BEST: {highScore}
              </div>
              <div style={{
                color: '#ffffff',
                fontSize: `${fs * 0.03}px`,
                letterSpacing: 7,
                textShadow: '0 0 18px #fff',
                animation: 'blink 1.3s ease-in-out infinite',
              }}>
                CLICK TO RETRY
              </div>
            </div>
          )}

          {/* Transparent input capture layer */}
          <div
            onClick={handleInput}
            onTouchEnd={e => { e.preventDefault(); handleInput(); }}
            style={{
              position: 'absolute', inset: 0,
              cursor: 'pointer',
              touchAction: 'none',
            }}
          />
        </div>
      );
    }

    ReactDOM.render(<VortexShift />, document.getElementById('root'));
  </script>
</body>
</html>
