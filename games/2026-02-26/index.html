<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Hopper</title>
  <!-- Synchronously seed localStorage before any CDN scripts load -->
  <script>
    try {
      if (localStorage.getItem('neonHopper_highScore') === null) {
        localStorage.setItem('neonHopper_highScore', '0');
      }
    } catch(e) {}
  </script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #05000f;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // ── Seed localStorage immediately (top-level, before React mounts) ───────
    const LS_KEY = 'neonHopper_highScore';
    if (localStorage.getItem(LS_KEY) === null) localStorage.setItem(LS_KEY, '0');

    // ── Constants ────────────────────────────────────────────────────────────
    const COLS = 10;
    const ROWS = 13;   // rows 0..12  (0=goal, 12=start)
    const CELL = 48;
    const W = COLS * CELL;  // 480
    const H = ROWS * CELL;  // 624

    // Neon palette for traffic lanes
    const LANE_COLORS = [
      '#ff3366', '#ff8800', '#ffee00',
      '#44ff88', '#00ccff', '#cc44ff',
    ];

    // Row configuration (index 0 = top / goal)
    const ROW_CFG = [
      { type: 'goal'  },
      { type: 'lane',  dir: -1, spd: 2.2 },
      { type: 'lane',  dir:  1, spd: 1.8 },
      { type: 'lane',  dir: -1, spd: 2.8 },
      { type: 'safe'  },
      { type: 'lane',  dir:  1, spd: 1.5 },
      { type: 'lane',  dir: -1, spd: 2.0 },
      { type: 'lane',  dir:  1, spd: 2.5 },
      { type: 'lane',  dir: -1, spd: 1.7 },
      { type: 'safe'  },
      { type: 'lane',  dir:  1, spd: 1.3 },
      { type: 'lane',  dir: -1, spd: 1.6 },
      { type: 'start' },
    ];

    // ── Helpers ──────────────────────────────────────────────────────────────
    function hexAlpha(hex, a) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${a})`;
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    // Build traffic for a given level (speed scales with level)
    function mkTraffic(lvl) {
      const arr = [];
      ROW_CFG.forEach((r, ri) => {
        if (r.type !== 'lane') return;
        const cnt   = 3 + Math.floor(Math.random() * 3);
        const color = LANE_COLORS[ri % LANE_COLORS.length];
        const spacing = W / cnt;
        for (let i = 0; i < cnt; i++) {
          arr.push({
            row: ri,
            x: spacing * i + Math.random() * spacing * 0.4,
            w: CELL * (1.4 + Math.random() * 0.9),
            spd: r.spd * (1 + (lvl - 1) * 0.18),
            dir: r.dir,
            color,
          });
        }
      });
      return arr;
    }

    // ── Audio helpers ────────────────────────────────────────────────────────
    let audioCtx = null;
    function getAudio() {
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) {}
      }
      return audioCtx;
    }
    function playNote(freq, dur, type = 'square', vol = 0.13, rampTo = null) {
      const ctx = getAudio(); if (!ctx) return;
      try {
        const osc = ctx.createOscillator();
        const g   = ctx.createGain();
        osc.connect(g); g.connect(ctx.destination);
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        if (rampTo) osc.frequency.exponentialRampToValueAtTime(rampTo, ctx.currentTime + dur);
        g.gain.setValueAtTime(vol, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
        osc.start(); osc.stop(ctx.currentTime + dur);
      } catch (e) {}
    }
    function playHop()  { playNote(440, 0.09, 'square', 0.12, 880); }
    function playDie()  { playNote(200, 0.55, 'sawtooth', 0.22, 40); }
    function playWin()  {
      [523, 659, 784, 1047].forEach((f, i) => {
        const ctx = getAudio(); if (!ctx) return;
        try {
          const osc = ctx.createOscillator();
          const g   = ctx.createGain();
          osc.connect(g); g.connect(ctx.destination);
          osc.type = 'sine';
          osc.frequency.setValueAtTime(f, ctx.currentTime + i * 0.1);
          g.gain.setValueAtTime(0.14, ctx.currentTime + i * 0.1);
          g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.1 + 0.3);
          osc.start(ctx.currentTime + i * 0.1);
          osc.stop(ctx.currentTime + i * 0.1 + 0.35);
        } catch (e) {}
      });
    }
    function playSafe() { playNote(660, 0.18, 'sine', 0.08, 880); }

    // ── Component ────────────────────────────────────────────────────────────
    const NeonHopper = () => {
      const canvasRef = useRef(null);
      const touchRef  = useRef(null);

      // All mutable game state lives here (no React re-renders needed for canvas)
      const gs = useRef({
        phase:      'start',   // 'start' | 'playing' | 'dead' | 'win'
        row:        12,
        col:        5,
        score:      0,
        highScore:  0,
        level:      1,
        traffic:    [],
        particles:  [],
        deathTimer: 0,
        winTimer:   0,
      });

      // Load persisted high score on mount
      useEffect(() => {
        const hs = parseInt(localStorage.getItem(LS_KEY) || '0');
        gs.current.highScore = hs;
      }, []);

      // ── Game actions ──────────────────────────────────────────────────────
      const startGame = useCallback(() => {
        const g = gs.current;
        g.phase      = 'playing';
        g.row        = 12;
        g.col        = 5;
        g.score      = 0;
        g.traffic    = mkTraffic(g.level);
        g.particles  = [];
        g.deathTimer = 0;
        g.winTimer   = 0;
      }, []);

      const spawnParticles = (x, y, color, count = 22) => {
        const g = gs.current;
        for (let i = 0; i < count; i++) {
          const a = (Math.PI * 2 * i) / count + Math.random() * 0.5;
          const s = 2 + Math.random() * 4;
          g.particles.push({
            x, y,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s - 1,
            life: 1,
            decay: 0.015 + Math.random() * 0.02,
            size: 3 + Math.random() * 5,
            color,
          });
        }
      };

      const killPlayer = useCallback(() => {
        const g = gs.current;
        if (g.phase !== 'playing') return;
        g.phase      = 'dead';
        g.deathTimer = 130;
        playDie();
        spawnParticles(g.col * CELL + CELL / 2, g.row * CELL + CELL / 2, '#ff3366', 28);
        if (g.score > g.highScore) {
          g.highScore = g.score;
          localStorage.setItem(LS_KEY, String(g.score));
        }
      }, []);

      const movePlayer = useCallback((dr, dc) => {
        const g = gs.current;
        if (g.phase !== 'playing') return;
        const nr = g.row + dr;
        const nc = Math.max(0, Math.min(COLS - 1, g.col + dc));
        if (nr < 0 || nr > 12) return;

        playHop();
        g.row = nr;
        g.col = nc;

        // Reached goal row
        if (nr === 0) {
          const bonus = 100 * g.level;
          g.score += bonus;
          if (g.score > g.highScore) {
            g.highScore = g.score;
            localStorage.setItem(LS_KEY, String(g.score));
          }
          g.phase    = 'win';
          g.winTimer = 110;
          playWin();
          spawnParticles(nc * CELL + CELL / 2, CELL / 2, '#00ff88', 40);
          spawnParticles(W / 2, H / 2, '#ffff00', 25);
          return;
        }

        // Score: +10 per row moved forward (toward goal)
        if (dr < 0) {
          g.score += 10;
          const rowType = ROW_CFG[nr].type;
          if (rowType === 'safe') playSafe();
        }
      }, []);

      // ── Input handling ────────────────────────────────────────────────────
      useEffect(() => {
        const onKey = (e) => {
          const g = gs.current;
          const nav = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',
                       'w','a','s','d','W','A','S','D',' ','Enter'];
          if (nav.includes(e.key)) e.preventDefault();

          if (g.phase !== 'playing') {
            if ([' ','Enter','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
              if (g.phase === 'win')  g.level++;
              else                   g.level = 1;
              startGame();
            }
            return;
          }
          switch (e.key) {
            case 'ArrowUp':    case 'w': case 'W': movePlayer(-1,  0); break;
            case 'ArrowDown':  case 's': case 'S': movePlayer( 1,  0); break;
            case 'ArrowLeft':  case 'a': case 'A': movePlayer( 0, -1); break;
            case 'ArrowRight': case 'd': case 'D': movePlayer( 0,  1); break;
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [movePlayer, startGame]);

      const onTouchStart = useCallback((e) => {
        e.preventDefault();
        touchRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }, []);

      const onTouchEnd = useCallback((e) => {
        e.preventDefault();
        const g = gs.current;
        if (!touchRef.current) return;
        const dx = e.changedTouches[0].clientX - touchRef.current.x;
        const dy = e.changedTouches[0].clientY - touchRef.current.y;
        touchRef.current = null;

        if (g.phase !== 'playing') {
          if (g.phase === 'win')  g.level++;
          else                   g.level = 1;
          startGame();
          return;
        }
        if (Math.abs(dx) < 12 && Math.abs(dy) < 12) { movePlayer(-1, 0); return; }
        if (Math.abs(dx) > Math.abs(dy)) movePlayer(0, dx > 0 ? 1 : -1);
        else                              movePlayer(dy > 0 ? 1 : -1, 0);
      }, [movePlayer, startGame]);

      const onClick = useCallback(() => {
        const g = gs.current;
        if (g.phase !== 'playing') {
          if (g.phase === 'win')  g.level++;
          else                   g.level = 1;
          startGame();
        }
      }, [startGame]);

      // ── Main render loop ──────────────────────────────────────────────────
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        let raf;
        let t0 = performance.now();

        const loop = (now) => {
          raf = requestAnimationFrame(loop);
          t0  = now;
          const t = now / 1000;
          const g = gs.current;

          // ── Update ────────────────────────────────────────────────────────
          // Move traffic every frame
          if (g.phase === 'playing' || g.phase === 'dead') {
            g.traffic.forEach(v => {
              v.x += v.spd * v.dir;
              if (v.dir > 0 && v.x > W)         v.x = -v.w;
              if (v.dir < 0 && v.x + v.w < 0)   v.x = W;
            });
          }

          // Collision detection (only while playing)
          if (g.phase === 'playing') {
            const rowType = ROW_CFG[g.row].type;
            if (rowType === 'lane') {
              const cx = g.col * CELL + CELL * 0.2;
              const cw = CELL * 0.6;
              for (const v of g.traffic) {
                if (v.row !== g.row) continue;
                if (cx < v.x + v.w && cx + cw > v.x) {
                  killPlayer();
                  break;
                }
              }
            }
          }

          // Particles
          g.particles = g.particles.filter(p => p.life > 0);
          g.particles.forEach(p => {
            p.x  += p.vx;
            p.y  += p.vy;
            p.vy += 0.12;   // gravity
            p.life -= p.decay;
          });

          if (g.deathTimer > 0) g.deathTimer--;
          if (g.winTimer   > 0) g.winTimer--;

          // ── Draw ──────────────────────────────────────────────────────────
          ctx.fillStyle = '#05000f';
          ctx.fillRect(0, 0, W, H);

          // Rows
          ROW_CFG.forEach((r, ri) => {
            const ry = ri * CELL;
            if (r.type === 'goal') {
              const pulse = (Math.sin(t * 3) + 1) * 0.5;
              ctx.fillStyle = `rgba(0,${Math.floor(130 + pulse * 80)},${Math.floor(80 + pulse * 80)},0.35)`;
              ctx.fillRect(0, ry, W, CELL);
              ctx.strokeStyle = `rgba(0,255,170,${0.4 + pulse * 0.45})`;
              ctx.lineWidth = 2;
              ctx.strokeRect(1, ry + 1, W - 2, CELL - 2);
              ctx.fillStyle = `rgba(0,255,170,${0.55 + pulse * 0.45})`;
              ctx.font = 'bold 13px Courier New';
              ctx.textAlign = 'center';
              ctx.fillText('▲  G O A L  ▲', W / 2, ry + CELL / 2 + 5);
            } else if (r.type === 'safe' || r.type === 'start') {
              ctx.fillStyle = 'rgba(0,40,70,0.5)';
              ctx.fillRect(0, ry, W, CELL);
              // Grid cells
              ctx.strokeStyle = 'rgba(0,120,180,0.22)';
              ctx.lineWidth = 0.5;
              for (let c = 0; c < COLS; c++) {
                ctx.strokeRect(c * CELL, ry, CELL, CELL);
              }
              if (r.type === 'safe') {
                ctx.fillStyle = 'rgba(0,180,255,0.07)';
                ctx.fillRect(2, ry + 2, W - 4, CELL - 4);
              }
            } else {
              // Traffic lane
              const color = LANE_COLORS[ri % LANE_COLORS.length];
              ctx.fillStyle = 'rgba(12,0,22,0.85)';
              ctx.fillRect(0, ry, W, CELL);
              ctx.fillStyle = hexAlpha(color, 0.05);
              ctx.fillRect(0, ry, W, CELL);
              // Direction arrows
              ctx.fillStyle = hexAlpha(color, 0.14);
              ctx.font = '16px sans-serif';
              ctx.textAlign = 'center';
              const arrow = r.dir > 0 ? '→' : '←';
              for (let i = 1; i < COLS; i += 2) {
                ctx.fillText(arrow, i * CELL + CELL / 2, ry + CELL / 2 + 6);
              }
            }
          });

          // Horizontal dividers
          ctx.strokeStyle = 'rgba(40,40,90,0.4)';
          ctx.lineWidth = 0.5;
          for (let ri = 0; ri <= ROWS; ri++) {
            ctx.beginPath();
            ctx.moveTo(0, ri * CELL);
            ctx.lineTo(W, ri * CELL);
            ctx.stroke();
          }

          // Traffic vehicles
          g.traffic.forEach(v => {
            const vy = v.row * CELL + CELL * 0.15;
            const vh = CELL * 0.70;
            ctx.shadowColor = v.color;
            ctx.shadowBlur  = 10;
            ctx.fillStyle   = v.color;
            roundRect(ctx, v.x, vy, v.w, vh, 5);
            ctx.fill();
            // Highlight stripe
            ctx.fillStyle = 'rgba(255,255,255,0.22)';
            roundRect(ctx, v.x + 3, vy + 3, v.w - 6, vh * 0.28, 3);
            ctx.fill();
            ctx.shadowBlur = 0;
          });

          // Particles
          g.particles.forEach(p => {
            ctx.globalAlpha = Math.max(0, p.life);
            ctx.shadowColor = p.color;
            ctx.shadowBlur  = 8;
            ctx.fillStyle   = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, Math.max(0.5, p.size * p.life), 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.globalAlpha = 1;
          ctx.shadowBlur  = 0;

          // Player (hidden when dead)
          if (g.phase !== 'dead') {
            const px    = g.col * CELL + CELL / 2;
            const py    = g.row * CELL + CELL / 2;
            const sz    = CELL * 0.36;
            const pulse = (Math.sin(t * 7) + 1) * 0.5;
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(Math.PI / 4);
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur  = 14 + pulse * 14;
            ctx.fillStyle   = '#00ffff';
            ctx.fillRect(-sz, -sz, sz * 2, sz * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillRect(-sz * 0.38, -sz * 0.38, sz * 0.76, sz * 0.76);
            ctx.shadowBlur = 0;
            ctx.restore();
          }

          // Scanlines (subtle CRT)
          ctx.fillStyle = 'rgba(0,0,0,0.03)';
          for (let y = 0; y < H; y += 2) ctx.fillRect(0, y, W, 1);

          // HUD
          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur  = 6;
          ctx.fillStyle   = '#00ffff';
          ctx.font        = 'bold 17px Courier New';
          ctx.textAlign   = 'left';
          ctx.fillText(`Score: ${g.score}`, 10, 22);
          ctx.shadowBlur  = 0;
          ctx.fillStyle   = '#ff88ff';
          ctx.font        = '13px Courier New';
          ctx.textAlign   = 'right';
          ctx.fillText(`Best: ${g.highScore}`, W - 10, 22);
          ctx.fillStyle   = '#ffff44';
          ctx.fillText(`Lv ${g.level}`, W - 10, 39);

          // ── Phase overlays ─────────────────────────────────────────────────
          if (g.phase === 'start') {
            ctx.fillStyle = 'rgba(2,0,18,0.84)';
            ctx.fillRect(0, 0, W, H);
            const p = (Math.sin(t * 2.5) + 1) * 0.5;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur  = 14 + p * 26;
            ctx.fillStyle   = '#00e5ff';
            ctx.font        = 'bold 54px Courier New';
            ctx.textAlign   = 'center';
            ctx.fillText('NEON', W / 2, H / 2 - 58);
            ctx.fillStyle   = '#ff44ff';
            ctx.shadowColor = '#ff44ff';
            ctx.shadowBlur  = 14 + p * 26;
            ctx.fillText('HOPPER', W / 2, H / 2 - 3);
            ctx.shadowBlur  = 0;
            ctx.fillStyle   = '#bbbbbb';
            ctx.font        = '13px Courier New';
            ctx.fillText('Cross all lanes to reach the GOAL', W / 2, H / 2 + 40);
            ctx.fillText('Arrow keys / WASD   |   Swipe / Tap', W / 2, H / 2 + 60);
            ctx.fillStyle = `rgba(0,255,200,${0.45 + p * 0.55})`;
            ctx.font      = 'bold 15px Courier New';
            ctx.fillText('PRESS ANY KEY  or  TAP TO START', W / 2, H / 2 + 96);
          }

          if (g.phase === 'dead') {
            const alpha = Math.min(1, (130 - g.deathTimer) / 65);
            if (alpha > 0) {
              ctx.fillStyle = `rgba(20,0,0,${alpha * 0.76})`;
              ctx.fillRect(0, 0, W, H);
            }
            if (alpha > 0.35) {
              ctx.shadowColor = '#ff1133';
              ctx.shadowBlur  = 22;
              ctx.fillStyle   = '#ff2244';
              ctx.font        = 'bold 46px Courier New';
              ctx.textAlign   = 'center';
              ctx.fillText('BUSTED!', W / 2, H / 2 - 25);
              ctx.shadowBlur  = 0;
              ctx.fillStyle   = '#ffffff';
              ctx.font        = '16px Courier New';
              ctx.fillText(`Score: ${g.score}`, W / 2, H / 2 + 16);
              const p2 = (Math.sin(t * 4) + 1) * 0.5;
              ctx.fillStyle = `rgba(0,200,255,${0.45 + p2 * 0.55})`;
              ctx.font      = 'bold 14px Courier New';
              ctx.fillText('TAP or press key to RETRY', W / 2, H / 2 + 56);
            }
          }

          if (g.phase === 'win') {
            const alpha = Math.min(1, (110 - g.winTimer) / 55);
            if (alpha > 0) {
              ctx.fillStyle = `rgba(0,18,5,${alpha * 0.76})`;
              ctx.fillRect(0, 0, W, H);
            }
            if (alpha > 0.35) {
              const p3 = (Math.sin(t * 5) + 1) * 0.5;
              ctx.shadowColor = '#00ff88';
              ctx.shadowBlur  = 20 + p3 * 22;
              ctx.fillStyle   = `hsl(${140 + p3 * 30},100%,58%)`;
              ctx.font        = 'bold 38px Courier New';
              ctx.textAlign   = 'center';
              ctx.fillText('LEVEL CLEAR!', W / 2, H / 2 - 25);
              ctx.shadowBlur  = 0;
              ctx.fillStyle   = '#ffffff';
              ctx.font        = '15px Courier New';
              ctx.fillText(`+${100 * g.level} BONUS!   Score: ${g.score}`, W / 2, H / 2 + 15);
              ctx.fillStyle   = `rgba(255,255,0,${0.5 + p3 * 0.5})`;
              ctx.font        = 'bold 14px Courier New';
              ctx.fillText('TAP or press key for NEXT LEVEL', W / 2, H / 2 + 55);
            }
          }
        };

        raf = requestAnimationFrame(loop);
        return () => cancelAnimationFrame(raf);
      }, [killPlayer]);

      // Responsive scale
      const [scale, setScale] = useState(1);
      useEffect(() => {
        const resize = () => {
          const sw = (window.innerWidth  - 20) / W;
          const sh = (window.innerHeight - 20) / H;
          setScale(Math.min(1, sw, sh));
        };
        resize();
        window.addEventListener('resize', resize);
        return () => window.removeEventListener('resize', resize);
      }, []);

      return (
        <div style={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          width: '100vw',
          height: '100vh',
        }}>
          <canvas
            ref={canvasRef}
            id="game-canvas"
            width={W}
            height={H}
            onClick={onClick}
            onTouchStart={onTouchStart}
            onTouchEnd={onTouchEnd}
            style={{
              transform: `scale(${scale})`,
              transformOrigin: 'center center',
              cursor: 'pointer',
              touchAction: 'none',
              border: '2px solid #00aaff',
              boxShadow: '0 0 22px #00aaff80, 0 0 55px #ff00ff35',
              borderRadius: '4px',
            }}
          />
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<NeonHopper />);
  </script>
</body>
</html>
