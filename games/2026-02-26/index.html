<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Neon Hopper</title>
  <!-- Synchronously seed localStorage before any CDN scripts load -->
  <script>
    try {
      if (localStorage.getItem('neonHopper_highScore') === null) {
        localStorage.setItem('neonHopper_highScore', '0');
      }
    } catch(e) {}
  </script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      background: #05000f;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    #root {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // ── Seed localStorage ──────────────────────────────────────────────────────
    const LS_KEY = 'neonHopper_highScore';
    if (localStorage.getItem(LS_KEY) === null) localStorage.setItem(LS_KEY, '0');

    // ── Fixed layout constants ─────────────────────────────────────────────────
    const COLS = 10;
    const ROWS = 13;   // rows 0..12  (0=goal, 12=start)

    // Neon palette for traffic lanes
    const LANE_COLORS = [
      '#ff3366', '#ff8800', '#ffee00',
      '#44ff88', '#00ccff', '#cc44ff',
    ];

    // Row configuration (index 0 = top / goal)
    const ROW_CFG = [
      { type: 'goal'  },
      { type: 'lane',  dir: -1, spd: 2.2 },
      { type: 'lane',  dir:  1, spd: 1.8 },
      { type: 'lane',  dir: -1, spd: 2.8 },
      { type: 'safe'  },
      { type: 'lane',  dir:  1, spd: 1.5 },
      { type: 'lane',  dir: -1, spd: 2.0 },
      { type: 'lane',  dir:  1, spd: 2.5 },
      { type: 'lane',  dir: -1, spd: 1.7 },
      { type: 'safe'  },
      { type: 'lane',  dir:  1, spd: 1.3 },
      { type: 'lane',  dir: -1, spd: 1.6 },
      { type: 'start' },
    ];

    // ── Dynamic dimension calculation ──────────────────────────────────────────
    // On mobile (<768px wide) we reserve space for the 3-row D-pad below the canvas.
    // D-pad = 3 rows × 68px = 204px + 8px flex gap = 212px total.
    function calcDims() {
      const isMobile = window.innerWidth < 768;
      const dpadH    = isMobile ? 212 : 0;
      const pad      = 12;
      const availW   = window.innerWidth  - pad;
      const availH   = window.innerHeight - pad - dpadH;
      const byW      = Math.floor(availW / COLS);
      const byH      = Math.floor(availH / ROWS);
      const CELL     = Math.max(28, Math.min(byW, byH, 54)); // 28–54 px
      return { CELL, W: CELL * COLS, H: CELL * ROWS, isMobile };
    }

    // ── Helpers ────────────────────────────────────────────────────────────────
    function hexAlpha(hex, a) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${a})`;
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    // Build traffic for a given level. Accepts CELL and W so it works with
    // dynamically sized grids. On mobile, fewer/narrower cars to keep it fair.
    function mkTraffic(lvl, CELL, W, isMobile = false) {
      const arr = [];
      ROW_CFG.forEach((r, ri) => {
        if (r.type !== 'lane') return;
        // Mobile: 2–3 cars per lane; Desktop: 3–5 cars per lane
        const cnt   = isMobile
          ? 2 + Math.floor(Math.random() * 2)
          : 3 + Math.floor(Math.random() * 3);
        const color = LANE_COLORS[ri % LANE_COLORS.length];
        const spacing = W / cnt;
        // Mobile: cars are slightly narrower to leave bigger gaps
        const wMul = isMobile ? (1.1 + Math.random() * 0.7) : (1.4 + Math.random() * 0.9);
        for (let i = 0; i < cnt; i++) {
          arr.push({
            row: ri,
            x: spacing * i + Math.random() * spacing * 0.4,
            w: CELL * wMul,
            spd: r.spd * (1 + (lvl - 1) * 0.18),
            dir: r.dir,
            color,
          });
        }
      });
      return arr;
    }

    // ── Audio helpers ──────────────────────────────────────────────────────────
    let audioCtx = null;
    function getAudio() {
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) {}
      }
      return audioCtx;
    }
    function playNote(freq, dur, type = 'square', vol = 0.13, rampTo = null) {
      const ctx = getAudio(); if (!ctx) return;
      try {
        const osc = ctx.createOscillator();
        const g   = ctx.createGain();
        osc.connect(g); g.connect(ctx.destination);
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        if (rampTo) osc.frequency.exponentialRampToValueAtTime(rampTo, ctx.currentTime + dur);
        g.gain.setValueAtTime(vol, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
        osc.start(); osc.stop(ctx.currentTime + dur);
      } catch (e) {}
    }
    function playHop()  { playNote(440, 0.09, 'square', 0.12, 880); }
    function playDie()  { playNote(200, 0.55, 'sawtooth', 0.22, 40); }
    function playWin()  {
      [523, 659, 784, 1047].forEach((f, i) => {
        const ctx = getAudio(); if (!ctx) return;
        try {
          const osc = ctx.createOscillator();
          const g   = ctx.createGain();
          osc.connect(g); g.connect(ctx.destination);
          osc.type = 'sine';
          osc.frequency.setValueAtTime(f, ctx.currentTime + i * 0.1);
          g.gain.setValueAtTime(0.14, ctx.currentTime + i * 0.1);
          g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.1 + 0.3);
          osc.start(ctx.currentTime + i * 0.1);
          osc.stop(ctx.currentTime + i * 0.1 + 0.35);
        } catch (e) {}
      });
    }
    function playSafe() { playNote(660, 0.18, 'sine', 0.08, 880); }

    // ── Component ──────────────────────────────────────────────────────────────
    const NeonHopper = () => {
      const canvasRef = useRef(null);
      const touchRef  = useRef(null);

      // Reactive dims (triggers re-render → updates canvas width/height attrs)
      const [dims, setDims] = useState(() => calcDims());
      // Sync ref for the render loop (avoids stale closure)
      const dimsRef = useRef(dims);

      // All mutable game state lives here (no React re-renders needed for canvas)
      const gs = useRef({
        phase:      'start',
        row:        12,
        col:        5,
        score:      0,
        highScore:  0,
        level:      1,
        traffic:    [],
        particles:  [],
        deathTimer: 0,
        winTimer:   0,
      });

      // Load persisted high score on mount
      useEffect(() => {
        const hs = parseInt(localStorage.getItem(LS_KEY) || '0');
        gs.current.highScore = hs;
      }, []);

      // ── Game actions ────────────────────────────────────────────────────────
      const startGame = useCallback(() => {
        const g = gs.current;
        const { CELL, W } = dimsRef.current;
        g.phase      = 'playing';
        g.row        = 12;
        g.col        = 5;
        g.score      = 0;
        g.traffic    = mkTraffic(g.level, CELL, W, dimsRef.current.isMobile);
        g.particles  = [];
        g.deathTimer = 0;
        g.winTimer   = 0;
      }, []);

      const spawnParticles = (x, y, color, count = 22) => {
        const g = gs.current;
        for (let i = 0; i < count; i++) {
          const a = (Math.PI * 2 * i) / count + Math.random() * 0.5;
          const s = 2 + Math.random() * 4;
          g.particles.push({
            x, y,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s - 1,
            life: 1,
            decay: 0.015 + Math.random() * 0.02,
            size: 3 + Math.random() * 5,
            color,
          });
        }
      };

      const killPlayer = useCallback(() => {
        const g = gs.current;
        if (g.phase !== 'playing') return;
        const { CELL } = dimsRef.current;
        g.phase      = 'dead';
        g.deathTimer = 130;
        playDie();
        spawnParticles(g.col * CELL + CELL / 2, g.row * CELL + CELL / 2, '#ff3366', 28);
        if (g.score > g.highScore) {
          g.highScore = g.score;
          localStorage.setItem(LS_KEY, String(g.score));
        }
      }, []);

      const movePlayer = useCallback((dr, dc) => {
        const g = gs.current;
        const { CELL, W, H } = dimsRef.current;
        if (g.phase !== 'playing') return;
        const nr = g.row + dr;
        const nc = Math.max(0, Math.min(COLS - 1, g.col + dc));
        if (nr < 0 || nr > 12) return;

        playHop();
        g.row = nr;
        g.col = nc;

        if (nr === 0) {
          const bonus = 100 * g.level;
          g.score += bonus;
          if (g.score > g.highScore) {
            g.highScore = g.score;
            localStorage.setItem(LS_KEY, String(g.score));
          }
          g.phase    = 'win';
          g.winTimer = 110;
          playWin();
          spawnParticles(nc * CELL + CELL / 2, CELL / 2, '#00ff88', 40);
          spawnParticles(W / 2, H / 2, '#ffff00', 25);
          return;
        }

        if (dr < 0) {
          g.score += 10;
          const rowType = ROW_CFG[nr].type;
          if (rowType === 'safe') playSafe();
        }
      }, []);

      // ── Resize handling ─────────────────────────────────────────────────────
      useEffect(() => {
        const onResize = () => {
          const newDims = calcDims();
          const oldW    = dimsRef.current.W;
          const ratio   = newDims.W / oldW;
          // Scale traffic and particle positions proportionally
          gs.current.traffic.forEach(v => { v.x *= ratio; v.w *= ratio; });
          gs.current.particles.forEach(p => { p.x *= ratio; p.y *= ratio; });
          dimsRef.current = newDims;
          setDims(newDims);
        };
        window.addEventListener('resize', onResize);
        return () => window.removeEventListener('resize', onResize);
      }, []);

      // ── Keyboard input ──────────────────────────────────────────────────────
      useEffect(() => {
        const onKey = (e) => {
          const g = gs.current;
          const nav = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',
                       'w','a','s','d','W','A','S','D',' ','Enter'];
          if (nav.includes(e.key)) e.preventDefault();

          if (g.phase !== 'playing') {
            if ([' ','Enter','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
              if (g.phase === 'win')  g.level++;
              else                   g.level = 1;
              startGame();
            }
            return;
          }
          switch (e.key) {
            case 'ArrowUp':    case 'w': case 'W': movePlayer(-1,  0); break;
            case 'ArrowDown':  case 's': case 'S': movePlayer( 1,  0); break;
            case 'ArrowLeft':  case 'a': case 'A': movePlayer( 0, -1); break;
            case 'ArrowRight': case 'd': case 'D': movePlayer( 0,  1); break;
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [movePlayer, startGame]);

      // ── Touch/swipe on canvas ───────────────────────────────────────────────
      const onTouchStart = useCallback((e) => {
        e.preventDefault();
        touchRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }, []);

      const onTouchEnd = useCallback((e) => {
        e.preventDefault();
        const g = gs.current;
        if (!touchRef.current) return;
        const dx = e.changedTouches[0].clientX - touchRef.current.x;
        const dy = e.changedTouches[0].clientY - touchRef.current.y;
        touchRef.current = null;

        if (g.phase !== 'playing') {
          if (g.phase === 'win')  g.level++;
          else                   g.level = 1;
          startGame();
          return;
        }
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 16) { movePlayer(-1, 0); return; } // tap → hop forward
        if (Math.abs(dx) > Math.abs(dy)) movePlayer(0, dx > 0 ? 1 : -1);
        else                              movePlayer(dy > 0 ? 1 : -1, 0);
      }, [movePlayer, startGame]);

      const onClick = useCallback(() => {
        const g = gs.current;
        if (g.phase !== 'playing') {
          if (g.phase === 'win')  g.level++;
          else                   g.level = 1;
          startGame();
        }
      }, [startGame]);

      // ── D-pad handlers ──────────────────────────────────────────────────────
      const makeDpadHandler = (dr, dc) => (e) => {
        e.preventDefault();
        const g = gs.current;
        if (g.phase !== 'playing') {
          if (g.phase === 'win')  g.level++;
          else                   g.level = 1;
          startGame();
          return;
        }
        movePlayer(dr, dc);
      };
      const dpadUp    = useCallback(makeDpadHandler(-1,  0), [movePlayer, startGame]);
      const dpadDown  = useCallback(makeDpadHandler( 1,  0), [movePlayer, startGame]);
      const dpadLeft  = useCallback(makeDpadHandler( 0, -1), [movePlayer, startGame]);
      const dpadRight = useCallback(makeDpadHandler( 0,  1), [movePlayer, startGame]);

      // ── Main render loop ────────────────────────────────────────────────────
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        let raf;

        const loop = (now) => {
          raf = requestAnimationFrame(loop);
          const t = now / 1000;
          const g = gs.current;
          const { CELL, W, H } = dimsRef.current;

          // ── Update ──────────────────────────────────────────────────────────
          if (g.phase === 'playing' || g.phase === 'dead') {
            g.traffic.forEach(v => {
              v.x += v.spd * v.dir;
              if (v.dir > 0 && v.x > W)         v.x = -v.w;
              if (v.dir < 0 && v.x + v.w < 0)   v.x = W;
            });
          }

          if (g.phase === 'playing') {
            const rowType = ROW_CFG[g.row].type;
            if (rowType === 'lane') {
              const cx = g.col * CELL + CELL * 0.2;
              const cw = CELL * 0.6;
              for (const v of g.traffic) {
                if (v.row !== g.row) continue;
                if (cx < v.x + v.w && cx + cw > v.x) { killPlayer(); break; }
              }
            }
          }

          g.particles = g.particles.filter(p => p.life > 0);
          g.particles.forEach(p => {
            p.x  += p.vx;
            p.y  += p.vy;
            p.vy += 0.12;
            p.life -= p.decay;
          });

          if (g.deathTimer > 0) g.deathTimer--;
          if (g.winTimer   > 0) g.winTimer--;

          // ── Draw ────────────────────────────────────────────────────────────
          ctx.fillStyle = '#05000f';
          ctx.fillRect(0, 0, W, H);

          // Rows
          ROW_CFG.forEach((r, ri) => {
            const ry = ri * CELL;
            if (r.type === 'goal') {
              const pulse = (Math.sin(t * 3) + 1) * 0.5;
              ctx.fillStyle = `rgba(0,${Math.floor(130 + pulse * 80)},${Math.floor(80 + pulse * 80)},0.35)`;
              ctx.fillRect(0, ry, W, CELL);
              ctx.strokeStyle = `rgba(0,255,170,${0.4 + pulse * 0.45})`;
              ctx.lineWidth = 2;
              ctx.strokeRect(1, ry + 1, W - 2, CELL - 2);
              ctx.fillStyle = `rgba(0,255,170,${0.55 + pulse * 0.45})`;
              ctx.font = `bold ${Math.max(9, Math.round(CELL * 0.27))}px Courier New`;
              ctx.textAlign = 'center';
              ctx.fillText('▲  G O A L  ▲', W / 2, ry + CELL / 2 + Math.round(CELL * 0.12));
            } else if (r.type === 'safe' || r.type === 'start') {
              ctx.fillStyle = 'rgba(0,40,70,0.5)';
              ctx.fillRect(0, ry, W, CELL);
              ctx.strokeStyle = 'rgba(0,120,180,0.22)';
              ctx.lineWidth = 0.5;
              for (let c = 0; c < COLS; c++) ctx.strokeRect(c * CELL, ry, CELL, CELL);
              if (r.type === 'safe') {
                ctx.fillStyle = 'rgba(0,180,255,0.07)';
                ctx.fillRect(2, ry + 2, W - 4, CELL - 4);
              }
            } else {
              const color = LANE_COLORS[ri % LANE_COLORS.length];
              ctx.fillStyle = 'rgba(12,0,22,0.85)';
              ctx.fillRect(0, ry, W, CELL);
              ctx.fillStyle = hexAlpha(color, 0.05);
              ctx.fillRect(0, ry, W, CELL);
              ctx.fillStyle = hexAlpha(color, 0.14);
              ctx.font = `${Math.max(10, Math.round(CELL * 0.33))}px sans-serif`;
              ctx.textAlign = 'center';
              const arrow = r.dir > 0 ? '→' : '←';
              for (let i = 1; i < COLS; i += 2) {
                ctx.fillText(arrow, i * CELL + CELL / 2, ry + CELL / 2 + Math.round(CELL * 0.13));
              }
            }
          });

          // Horizontal dividers
          ctx.strokeStyle = 'rgba(40,40,90,0.4)';
          ctx.lineWidth = 0.5;
          for (let ri = 0; ri <= ROWS; ri++) {
            ctx.beginPath(); ctx.moveTo(0, ri * CELL); ctx.lineTo(W, ri * CELL); ctx.stroke();
          }

          // Traffic vehicles
          g.traffic.forEach(v => {
            const vy = v.row * CELL + CELL * 0.15;
            const vh = CELL * 0.70;
            ctx.shadowColor = v.color;
            ctx.shadowBlur  = 10;
            ctx.fillStyle   = v.color;
            roundRect(ctx, v.x, vy, v.w, vh, 5);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.22)';
            roundRect(ctx, v.x + 3, vy + 3, v.w - 6, vh * 0.28, 3);
            ctx.fill();
            ctx.shadowBlur = 0;
          });

          // Particles
          g.particles.forEach(p => {
            ctx.globalAlpha = Math.max(0, p.life);
            ctx.shadowColor = p.color;
            ctx.shadowBlur  = 8;
            ctx.fillStyle   = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, Math.max(0.5, p.size * p.life), 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.globalAlpha = 1;
          ctx.shadowBlur  = 0;

          // Player (hidden when dead)
          if (g.phase !== 'dead') {
            const px    = g.col * CELL + CELL / 2;
            const py    = g.row * CELL + CELL / 2;
            const sz    = CELL * 0.36;
            const pulse = (Math.sin(t * 7) + 1) * 0.5;
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(Math.PI / 4);
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur  = 14 + pulse * 14;
            ctx.fillStyle   = '#00ffff';
            ctx.fillRect(-sz, -sz, sz * 2, sz * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillRect(-sz * 0.38, -sz * 0.38, sz * 0.76, sz * 0.76);
            ctx.shadowBlur = 0;
            ctx.restore();
          }

          // Scanlines (subtle CRT)
          ctx.fillStyle = 'rgba(0,0,0,0.03)';
          for (let y = 0; y < H; y += 2) ctx.fillRect(0, y, W, 1);

          // HUD
          const hudFS = Math.max(11, Math.round(CELL * 0.36));
          const hudFS2 = Math.max(9,  Math.round(CELL * 0.27));
          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur  = 6;
          ctx.fillStyle   = '#00ffff';
          ctx.font        = `bold ${hudFS}px Courier New`;
          ctx.textAlign   = 'left';
          ctx.fillText(`Score: ${g.score}`, 8, hudFS + 4);
          ctx.shadowBlur  = 0;
          ctx.fillStyle   = '#ff88ff';
          ctx.font        = `${hudFS2}px Courier New`;
          ctx.textAlign   = 'right';
          ctx.fillText(`Best: ${g.highScore}`, W - 8, hudFS2 + 4);
          ctx.fillStyle   = '#ffff44';
          ctx.fillText(`Lv ${g.level}`, W - 8, hudFS2 * 2 + 5);

          // ── Phase overlays ──────────────────────────────────────────────────
          if (g.phase === 'start') {
            ctx.fillStyle = 'rgba(2,0,18,0.84)';
            ctx.fillRect(0, 0, W, H);
            const p = (Math.sin(t * 2.5) + 1) * 0.5;
            const titleFS = Math.max(24, Math.round(CELL * 1.05));
            const subFS   = Math.max(10, Math.round(CELL * 0.26));
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur  = 14 + p * 26;
            ctx.fillStyle   = '#00e5ff';
            ctx.font        = `bold ${titleFS}px Courier New`;
            ctx.textAlign   = 'center';
            ctx.fillText('NEON', W / 2, H / 2 - titleFS * 1.15);
            ctx.fillStyle   = '#ff44ff';
            ctx.shadowColor = '#ff44ff';
            ctx.fillText('HOPPER', W / 2, H / 2 - titleFS * 0.05);
            ctx.shadowBlur  = 0;
            ctx.fillStyle   = '#bbbbbb';
            ctx.font        = `${subFS}px Courier New`;
            ctx.fillText('Cross all lanes to reach the GOAL', W / 2, H / 2 + titleFS * 0.85);
            ctx.fillText('Arrow keys / WASD  |  D-pad / Swipe', W / 2, H / 2 + titleFS * 1.15);
            ctx.fillStyle = `rgba(0,255,200,${0.45 + p * 0.55})`;
            ctx.font      = `bold ${Math.round(subFS * 1.1)}px Courier New`;
            ctx.fillText('TAP  or  PRESS ANY KEY  TO START', W / 2, H / 2 + titleFS * 1.6);
          }

          if (g.phase === 'dead') {
            const alpha = Math.min(1, (130 - g.deathTimer) / 65);
            if (alpha > 0) {
              ctx.fillStyle = `rgba(20,0,0,${alpha * 0.76})`;
              ctx.fillRect(0, 0, W, H);
            }
            if (alpha > 0.35) {
              const bigFS = Math.max(22, Math.round(CELL * 0.92));
              const smFS  = Math.max(11, Math.round(CELL * 0.32));
              ctx.shadowColor = '#ff1133';
              ctx.shadowBlur  = 22;
              ctx.fillStyle   = '#ff2244';
              ctx.font        = `bold ${bigFS}px Courier New`;
              ctx.textAlign   = 'center';
              ctx.fillText('BUSTED!', W / 2, H / 2 - bigFS * 0.4);
              ctx.shadowBlur  = 0;
              ctx.fillStyle   = '#ffffff';
              ctx.font        = `${smFS}px Courier New`;
              ctx.fillText(`Score: ${g.score}`, W / 2, H / 2 + smFS * 0.7);
              const p2 = (Math.sin(t * 4) + 1) * 0.5;
              ctx.fillStyle = `rgba(0,200,255,${0.45 + p2 * 0.55})`;
              ctx.font      = `bold ${smFS}px Courier New`;
              ctx.fillText('TAP or press key to RETRY', W / 2, H / 2 + smFS * 2.2);
            }
          }

          if (g.phase === 'win') {
            const alpha = Math.min(1, (110 - g.winTimer) / 55);
            if (alpha > 0) {
              ctx.fillStyle = `rgba(0,18,5,${alpha * 0.76})`;
              ctx.fillRect(0, 0, W, H);
            }
            if (alpha > 0.35) {
              const bigFS = Math.max(18, Math.round(CELL * 0.76));
              const smFS  = Math.max(11, Math.round(CELL * 0.30));
              const p3 = (Math.sin(t * 5) + 1) * 0.5;
              ctx.shadowColor = '#00ff88';
              ctx.shadowBlur  = 20 + p3 * 22;
              ctx.fillStyle   = `hsl(${140 + p3 * 30},100%,58%)`;
              ctx.font        = `bold ${bigFS}px Courier New`;
              ctx.textAlign   = 'center';
              ctx.fillText('LEVEL CLEAR!', W / 2, H / 2 - bigFS * 0.4);
              ctx.shadowBlur  = 0;
              ctx.fillStyle   = '#ffffff';
              ctx.font        = `${smFS}px Courier New`;
              ctx.fillText(`+${100 * g.level} BONUS!   Score: ${g.score}`, W / 2, H / 2 + smFS * 0.7);
              ctx.fillStyle   = `rgba(255,255,0,${0.5 + p3 * 0.5})`;
              ctx.font        = `bold ${smFS}px Courier New`;
              ctx.fillText('TAP or press key for NEXT LEVEL', W / 2, H / 2 + smFS * 2.2);
            }
          }
        };

        raf = requestAnimationFrame(loop);
        return () => cancelAnimationFrame(raf);
      }, [killPlayer]);

      // ── Render ──────────────────────────────────────────────────────────────
      const { W, H, isMobile } = dims;

      const dpadBtnBase = {
        background: 'rgba(0,180,255,0.12)',
        border: '2px solid rgba(0,180,255,0.45)',
        borderRadius: '14px',
        color: '#00ccff',
        fontSize: '22px',
        lineHeight: 1,
        width: '60px',
        height: '60px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        cursor: 'pointer',
        touchAction: 'manipulation',
        boxShadow: '0 0 10px rgba(0,180,255,0.25)',
        WebkitTapHighlightColor: 'transparent',
      };

      return (
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          width: '100vw',
          height: '100vh',
          gap: '8px',
        }}>
          <canvas
            ref={canvasRef}
            width={W}
            height={H}
            onClick={onClick}
            onTouchStart={onTouchStart}
            onTouchEnd={onTouchEnd}
            style={{
              display: 'block',
              cursor: 'pointer',
              touchAction: 'none',
              border: '2px solid #00aaff',
              boxShadow: '0 0 22px #00aaff80, 0 0 55px #ff00ff35',
              borderRadius: '4px',
            }}
          />
          {isMobile && (
            <div style={{
              display: 'grid',
              gridTemplateAreas: '". up ." "left . right" ". down ."',
              gridTemplateColumns: '68px 68px 68px',
              gridTemplateRows: '68px 68px 68px',
              gap: '0px',
            }}>
              <div style={{ ...dpadBtnBase, gridArea: 'up' }}
                   onPointerDown={dpadUp}>▲</div>
              <div style={{ ...dpadBtnBase, gridArea: 'left' }}
                   onPointerDown={dpadLeft}>◄</div>
              <div style={{ ...dpadBtnBase, gridArea: 'right' }}
                   onPointerDown={dpadRight}>►</div>
              <div style={{ ...dpadBtnBase, gridArea: 'down' }}
                   onPointerDown={dpadDown}>▼</div>
            </div>
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<NeonHopper />);
  </script>
</body>
</html>
